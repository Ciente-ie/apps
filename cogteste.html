<!DOCTYPE html>

<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Ferramenta de Avaliação Cognitiva para Atletas</title>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&amp;display=swap" rel="stylesheet"/>
<style>
        body { font-family: 'Inter', sans-serif; }
        .view { display: none; }
        .view.active { display: block; }
        .modal-bg { background-color: rgba(0, 0, 0, 0.5); z-index: 50; }
        
        /* Estilos Gerais de Teste */
        #test-stimulus-area {
            height: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #f0f4f8;
            border-radius: 0.5rem;
            position: relative;
            overflow: hidden;
        }
        
        /* Estilos do Teste Go/No-Go */
        .stimulus-circle { width: 150px; height: 150px; border-radius: 50%; }
        .go { background-color: #22c55e; }
        .no-go { background-color: #22c55e; border: 10px solid #ef4444; box-sizing: border-box; }
        
        /* Estilos do Teste Stroop */
        #stroop-stimulus-container { flex-grow: 1; display: flex; align-items: center; justify-content: center; }
        #stroop-stimulus { font-size: 4rem; font-weight: bold; }
        #stroop-choices { display: flex; justify-content: center; gap: 1rem; margin-bottom: 2rem; }
        .stroop-choice-btn { width: 180px; padding: 1rem 0; font-size: 1.5rem; font-weight: bold; border-radius: 0.5rem; border: 2px solid #cbd5e1; cursor: pointer; background-color: #f1f5f9; color: #1e293b; transition: all 0.2s; }
        .stroop-choice-btn:hover { background-color: #e2e8f0; }
        .stroop-choice-btn:disabled { cursor: not-allowed; opacity: 0.7; }
        .stroop-choice-btn.clicked { border-color: #3b82f6; border-width: 3px; }

        /* Estilos da Memória de Trabalho */
        #wm-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.5rem; width: 350px; height: 350px; }
        .wm-cell { background-color: white; border: 2px solid #cbd5e1; border-radius: 0.25rem; }
        .wm-cell.stimulus { background-color: #3b82f6; } /* Azul para mostrar a sequência */
        .wm-cell.selectable { cursor: pointer; }
        .wm-cell.selectable:hover { background-color: #e0e7ff; }
        .wm-cell.selected { background-color: #6366f1; border-color: #4f46e5; }
        .wm-cell.incorrect-feedback { background-color: #ef4444; border-color: #dc2626; }

        /* Estilos do Mapeamento Visual */
        #vm-canvas { background-color: #e2e8f0; border-radius: 0.5rem; cursor: pointer; }

        #countdown-timer { position: absolute; top: 1rem; right: 1rem; font-size: 2rem; font-weight: bold; color: #ef4444; }
        #progress-bar-container { 
            position: absolute; 
            bottom: 1rem; 
            width: 80%; 
            height: 10px; 
            background-color: #e5e7eb; 
            border-radius: 5px; 
            overflow: hidden;
        }
        #progress-bar { 
            height: 100%; 
            background-color: #3b82f6; 
            width: 100%; 
            transition: width 1s linear;
        }
        .delta-positive { color: #ef4444; } /* Vermelho para piora */
        .delta-negative { color: #22c55e; } /* Verde para melhora */
        .delta-neutral { color: #64748b; } /* Cinza para neutro */

        /* Estilos do Gráfico de Desempenho */
        .performance-bar-container { background-color: #e5e7eb; border-radius: 0.5rem; overflow: hidden; height: 24px; }
        .performance-bar { height: 100%; transition: all 0.5s ease-in-out; text-align: right; padding-right: 8px; color: white; font-weight: 500; font-size: 0.875rem; line-height: 24px; }
    </style>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore-compat.js"></script>
<script>
      const firebaseConfig = {
        apiKey: "AIzaSyDsoutLk5gmxq5zlu548HWFrox37u1zrxk",
        authDomain: "appintegrado-ciente.firebaseapp.com",
        projectId: "appintegrado-ciente",
        storageBucket: "appintegrado-ciente.firebasestorage.app",
        messagingSenderId: "487559108410",
        appId: "1:487559108410:web:08868011454e609ee52203"
      };
      firebase.initializeApp(firebaseConfig);
      const db = firebase.firestore();

      function enviarTesteParaFirebase(nome, idade, modalidade, teste, n2, n3) {
        const dados = {
          Nome: nome,
          Idade: idade,
          Modalidade: modalidade,
          Data: new Date().toISOString(),
          Teste: teste,
          "Índice N2": n2,
          "Índice N3": n3
        };
        db.collection("Cogteste").add(dados)
          .then(() => {
            alert("✅ Resultado enviado com sucesso para o Firebase!");
          })
          .catch((error) => {
            alert("❌ Erro ao enviar: " + error.message);
          });
      }
    </script>
</head>
<body class="bg-gray-100 text-gray-800">
<div class="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8" id="app">
<header class="mb-8">
<h1 class="text-3xl font-bold text-gray-900">Plataforma de Avaliação Cognitiva</h1>
<p class="text-gray-600 mt-1">Gerencie e avalie o desempenho cognitivo dos seus atletas.</p>
</header>
<nav class="mb-8">
<button class="px-4 py-2 bg-blue-600 text-white rounded-lg shadow hover:bg-blue-700 transition" id="nav-dashboard">Atletas</button>
</nav>
<main>
<div class="view active" id="dashboard-view"><div class="flex justify-between items-center mb-6"><h2 class="text-2xl font-semibold">Lista de Atletas</h2><button class="px-4 py-2 bg-green-600 text-white rounded-lg shadow hover:bg-green-700 transition flex items-center" id="add-athlete-btn"><i class="fas fa-plus mr-2"></i> Adicionar Atleta</button></div><div class="bg-white p-6 rounded-lg shadow-md" id="athlete-list"></div></div>
<div class="view" id="profile-view"><button class="mb-6 px-4 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400 transition flex items-center" id="back-to-dashboard-btn"><i class="fas fa-arrow-left mr-2"></i> Voltar</button><div class="bg-white p-6 rounded-lg shadow-md" id="athlete-profile-content"></div></div>
<div class="view" id="test-runner-view"><div class="relative bg-white p-8 rounded-lg shadow-md text-center" id="test-content-wrapper"><button class="absolute top-2 right-2 px-3 py-1 bg-red-500 text-white text-sm rounded-lg hover:bg-red-600 transition" id="cancel-test-btn">Cancelar Teste</button><div id="test-content"></div></div></div>
</main>
<div class="fixed inset-0 modal-bg items-center justify-center hidden" id="athlete-modal"><div class="bg-white p-8 rounded-lg shadow-2xl w-full max-w-lg m-4"><h3 class="text-2xl font-bold mb-6" id="modal-title"></h3><form id="athlete-form"><input id="athlete-id" type="hidden"/><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700" for="name">Nome Completo</label><input class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" id="name" required="" type="text"/></div><div><label class="block text-sm font-medium text-gray-700" for="dob">Data de Nascimento</label><input class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" id="dob" required="" type="date"/></div><div><label class="block text-sm font-medium text-gray-700" for="sport">Esporte</label><input class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" id="sport" type="text"/></div><div><label class="block text-sm font-medium text-gray-700" for="gender">Sexo</label><select class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" id="gender"><option value="Masculino">Masculino</option><option value="Feminino">Feminino</option></select></div></div><div class="mt-6 flex justify-end space-x-4"><button class="px-4 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400 transition" id="cancel-btn" type="button">Cancelar</button><button class="px-4 py-2 bg-blue-600 text-white rounded-lg shadow hover:bg-blue-700 transition" type="submit">Salvar</button></div></form></div></div>
<div class="fixed inset-0 modal-bg items-center justify-center hidden" id="report-modal"><div class="bg-white p-8 rounded-lg shadow-2xl w-full max-w-4xl m-4 overflow-y-auto max-h-screen"><div id="report-content"></div>
    <div class="mt-6 flex justify-between items-center">
      <button class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition" onclick="enviarParaFirebase()">Enviar para Firebase</button>
      <button class="px-4 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400 transition" id="close-report-btn">Fechar</button>
    </div>
    </div></div>
<div class="fixed inset-0 modal-bg items-center justify-center hidden" id="global-suggestions-modal"><div class="bg-white p-8 rounded-lg shadow-2xl w-full max-w-4xl m-4 overflow-y-auto max-h-screen"><div id="global-suggestions-content"></div><div class="mt-6 text-right"><button class="px-4 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400 transition" id="close-global-suggestions-btn">Fechar</button></div></div></div>
</div>
<script type="module">

// Barra regressiva universal para Nível 3
window.startProgressBar = function(duration) {
    const bar = document.getElementById('progress-bar');
    if (!bar) return;
    bar.style.width = '100%';
    let elapsed = 0;
    if (window.progressBarInterval) clearInterval(window.progressBarInterval);
    window.progressBarInterval = setInterval(() => {
        elapsed += 0.1;
        const percent = Math.max(0, 100 - (elapsed / duration) * 100);
        bar.style.width = percent + '%';
        if (elapsed >= duration) {
            bar.style.width = '0%';
            clearInterval(window.progressBarInterval);
        }
    }, 100);
};
window.stopProgressBar = function() {
    if (window.progressBarInterval) clearInterval(window.progressBarInterval);
    const bar = document.getElementById('progress-bar');
    if (bar) bar.style.width = '0%';
};
// Função para exibir estímulo do N3 SEMPRE mantendo a barra fixa acima
function mostrarNivel3ComBarra(htmlEstimulo, duracaoN3s) {
    const testContent = document.getElementById('test-content');
    testContent.innerHTML = `
        <div id="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
        <div id="test-stimulus-area">${htmlEstimulo}</div>
    `;
    window.startProgressBar(duracaoN3s);
}
function atualizarEstimuloNivel3(novoHtmlEstimulo) {
    const stim = document.getElementById('test-stimulus-area');
    if (stim) stim.innerHTML = novoHtmlEstimulo;
}


        // --- MÓDULOS AUXILIARES ---
        const AudioManager = {
            audioCtx: null, timerId: null,
            init() { if (!this.audioCtx) { this.audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } },
            playBeep(freq = 880, duration = 0.1, vol = 0.1) { if (!this.audioCtx) return; const o = this.audioCtx.createOscillator(); const g = this.audioCtx.createGain(); o.connect(g); g.connect(this.audioCtx.destination); o.type = 'sine'; o.frequency.setValueAtTime(freq, this.audioCtx.currentTime); g.gain.setValueAtTime(vol, this.audioCtx.currentTime); o.start(); o.stop(this.audioCtx.currentTime + duration); },
            playErrorBeep() { this.playBeep(220, 0.2, 0.2); },
            startAcceleratingBeep(totalDuration) {
                this.stopBeep();
                let timeLeft = totalDuration;
                const tick = () => {
                    if (timeLeft <= 0) return;
                    this.playBeep();
                    const nextInterval = (timeLeft / totalDuration) * 1000;
                    timeLeft -= (nextInterval / 1000);
                    this.timerId = setTimeout(tick, Math.max(nextInterval, 150));
                };
                tick();
            },
            stopBeep() { if (this.timerId) clearTimeout(this.timerId); }
        };

        const NormativeData = {
            'Go/No-Go': { meanRT: 500, stdDevRT: 80, meanAcc: 95, stdDevAcc: 5 },
            'Atenção Seletiva': { meanRT: 1200, stdDevRT: 150, meanAcc: 97, stdDevAcc: 4, meanStab: 20, stdDevStab: 6 },
            'Memória de Trabalho': { meanRT: 2500, stdDevRT: 400, meanAcc: 90, stdDevAcc: 8, meanStab: 25, stdDevStab: 8 },
            'Mapeamento Visual': { meanRT: 3500, stdDevRT: 600, meanAcc: 85, stdDevAcc: 10 },
            'CognitiveTrends': {
                Speed: { mean: 1850, stdDev: 275 }, // Média atualizada de Stroop (1200) e Memória de Trabalho (2500)
                Stability: { mean: 22.5, stdDev: 5 },
                Accuracy: { muitoAcima: 0, acima: 1, normal: 4, abaixo: 6 }
            }
        };

        const Analysis = {
            calculateStdDev(arr) { const n = arr.length; if (n < 2) return 0; const mean = arr.reduce((a, b) => a + b) / n; const variance = arr.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / (n - 1); return Math.sqrt(variance); },
            
            /**
             * Calcula um índice de desempenho normalizado (0-100) para um determinado teste.
             * A pontuação é baseada em quão longe o desempenho do atleta está da média normativa (z-score).
             * Uma pontuação de 50 é a média. Pontuações mais altas são melhores.
             * @param {string} testName - O nome do teste para obter os dados normativos.
             * @param {object} athleteMetrics - As métricas do atleta ({ meanRT, accuracy }). A acurácia deve estar em formato de porcentagem (0-100).
             * @returns {number} - O índice de desempenho (0-100).
             */
            calculatePerformanceIndex(testName, athleteMetrics) {
                const norms = NormativeData[testName];
                // Verificação mais flexível dos dados
                if (!norms || !athleteMetrics) return 0;
                
                // Trata casos onde meanRT ou accuracy podem ser undefined/null
                const meanRT = athleteMetrics.meanRT || 0;
                const accuracy = athleteMetrics.accuracy || 0;
                
                // Se não temos dados válidos para calcular, retorna 0
                if (typeof meanRT !== 'number' || typeof accuracy !== 'number') return 0;

                // Calcula o Z-score para velocidade
                const zSpeed = (norms.meanRT - meanRT) / norms.stdDevRT;
                
                // Calcula o Z-score para acurácia
                const zAccuracy = (accuracy - norms.meanAcc) / norms.stdDevAcc;

                // Combina os Z-scores de velocidade e acurácia
                const combinedZ = (zSpeed + zAccuracy) / 2;
                
                // Converte para escala 0-100 (50 = média)
                const performanceIndex = Math.max(0, Math.min(100, (combinedZ * 15) + 50));
                
                return performanceIndex;
            },
            
            analyzeGoNoGoResults(levelData) {
                const analysis = {};
                levelData.forEach(level => {
                    const { level: levelNum, rawData } = level;
                    const totalTrials = level.trials || rawData.length;
                    const reactionTimes = rawData.filter(t => t.type === 'go' && t.result === 'click').map(t => t.reactionTime);
                    const commissionErrors = rawData.filter(t => t.type === 'no-go' && t.result === 'click').length;
                    const omissionErrors = rawData.filter(t => t.type === 'go' && t.result === 'timeout').length;
                    const correctGo = reactionTimes.length;
                    const correctNoGo = rawData.filter(t => t.type === 'no-go' && t.result === 'timeout').length;
                    const meanRT = reactionTimes.length > 0 ? reactionTimes.reduce((a, b) => a + b, 0) / reactionTimes.length : 0;
                    const stdDevRT = this.calculateStdDev(reactionTimes);
                    const stability = meanRT > 0 ? (stdDevRT / meanRT) * 100 : 0;
                    const accuracy = totalTrials > 0 ? ((correctGo + correctNoGo) / totalTrials) * 100 : 0;
                    const metrics = { meanRT, stability, commissionErrors, omissionErrors, accuracy };
                    // Garante que o performanceIndex seja calculado para todos os níveis
                    metrics.performanceIndex = this.calculatePerformanceIndex('Go/No-Go', { 
                        meanRT: metrics.meanRT, 
                        accuracy: metrics.accuracy 
                    });
                    analysis[`level${levelNum}`] = metrics;
                });
                const l2 = analysis.level2;
                const l3 = analysis.level3;
                if (l2 && l3) {
                    analysis.delta = {
                        meanRT: l3.meanRT - l2.meanRT,
                        stability: l3.stability - l2.stability,
                        commissionErrors: l3.commissionErrors - l2.commissionErrors,
                        omissionErrors: l3.omissionErrors - l2.omissionErrors,
                        accuracy: l3.accuracy - l2.accuracy,
                        performanceIndex: l3.performanceIndex - l2.performanceIndex
                    };
                }
                return analysis;
            },
            analyzeStroopResults(levelData) {
                const analysis = {};
                levelData.forEach(level => {
                    const { level: levelNum, rawData } = level;
                    const reactionTimes = rawData.filter(t => t.result === 'correct').map(t => t.reactionTime);
                    const errors = rawData.filter(t => t.result === 'incorrect').length;
                    const meanRT = reactionTimes.length > 0 ? reactionTimes.reduce((a, b) => a + b, 0) / reactionTimes.length : 0;
                    const stdDevRT = this.calculateStdDev(reactionTimes);
                    const stability = meanRT > 0 ? (stdDevRT / meanRT) * 100 : 0;
                    const accuracy = rawData.length > 0 ? (reactionTimes.length / rawData.length) * 100 : 0;
                    const metrics = { meanRT, stability, errors, accuracy };
                    // Garante que o performanceIndex seja calculado para todos os níveis
                    metrics.performanceIndex = this.calculatePerformanceIndex('Atenção Seletiva', { 
                        meanRT: metrics.meanRT, 
                        accuracy: metrics.accuracy 
                    });
                    analysis[`level${levelNum}`] = metrics;
                });
                const l1 = analysis.level1;
                const l2 = analysis.level2;
                const l3 = analysis.level3;
                if (l1 && l2) { analysis.stroopEffect = l2.meanRT - l1.meanRT; }
                if (l2 && l3) { 
                    analysis.pressureEffect = { 
                        meanRT: l3.meanRT - l2.meanRT, 
                        stability: l3.stability - l2.stability, 
                        errors: l3.errors - l2.errors, 
                        accuracy: l3.accuracy - l2.accuracy,
                        performanceIndex: l3.performanceIndex - l2.performanceIndex
                    }; 
                }
                return analysis;
            },
            analyzeWorkingMemoryResults(levelData) {
                const analysis = {};
                levelData.forEach(level => {
                    const { level: levelNum, rawData } = level;
                    const reactionTimes = rawData.map(t => t.reactionTime);
                    const errors = rawData.filter(t => t.result === 'incorrect').length;
                    const meanRT = reactionTimes.length > 0 ? reactionTimes.reduce((a, b) => a + b, 0) / reactionTimes.length : 0;
                    const stdDevRT = this.calculateStdDev(reactionTimes);
                    const stability = meanRT > 0 ? (stdDevRT / meanRT) * 100 : 0;
                    const accuracy = rawData.length > 0 ? ((rawData.length - errors) / rawData.length) * 100 : 0;
                    const metrics = { meanRT, stability, errors, accuracy };
                    // Garante que o performanceIndex seja calculado para todos os níveis
                    metrics.performanceIndex = this.calculatePerformanceIndex('Memória de Trabalho', { 
                        meanRT: metrics.meanRT, 
                        accuracy: metrics.accuracy 
                    });
                    analysis[`level${levelNum}`] = metrics;
                });
                const l2 = analysis.level2;
                const l3 = analysis.level3;
                if (l2 && l3) { 
                    analysis.pressureEffect = { 
                        meanRT: l3.meanRT - l2.meanRT, 
                        stability: l3.stability - l2.stability, 
                        errors: l3.errors - l2.errors, 
                        accuracy: l3.accuracy - l2.accuracy,
                        performanceIndex: l3.performanceIndex - l2.performanceIndex
                    }; 
                }
                return analysis;
            },
            analyzeVisualMappingResults(levelData) {
                const analysis = {};
                levelData.forEach(level => {
                    const { level: levelNum, rawData } = level;
                    const totalTrials = level.trials || rawData.length;
                    const reactionTimes = rawData.map(t => t.reactionTime);
                    const errors = rawData.filter(t => t.result === 'incorrect').length;
                    const meanRT = reactionTimes.length > 0 ? reactionTimes.reduce((a, b) => a + b, 0) / reactionTimes.length : 0;
                    const stdDevRT = this.calculateStdDev(reactionTimes);
                    const stability = meanRT > 0 ? (stdDevRT / meanRT) * 100 : 0;
                    const accuracy = totalTrials > 0 ? ((totalTrials - errors) / totalTrials) * 100 : 0;
                    const metrics = { meanRT, stability, errors, accuracy };
                    // Garante que o performanceIndex seja calculado para todos os níveis
                    metrics.performanceIndex = this.calculatePerformanceIndex('Mapeamento Visual', { 
                        meanRT: metrics.meanRT, 
                        accuracy: metrics.accuracy 
                    });
                    analysis[`level${levelNum}`] = metrics;
                });
                const l2 = analysis.level2;
                const l3 = analysis.level3;
                if (l2 && l3) {
                    analysis.pressureEffect = {
                        meanRT: l3.meanRT - l2.meanRT,
                        stability: l3.stability - l2.stability,
                        errors: l3.errors - l2.errors,
                        accuracy: l3.accuracy - l2.accuracy,
                        performanceIndex: l3.performanceIndex - l2.performanceIndex
                    };
                }
                return analysis;
            },
            analyzeCognitiveTrends(sessions) {
                const stroopSession = sessions.filter(s => s.testName === 'Atenção Seletiva').sort((a,b) => new Date(b.completedAt) - new Date(a.completedAt))[0];
                const wmSession = sessions.filter(s => s.testName === 'Memória de Trabalho').sort((a,b) => new Date(b.completedAt) - new Date(a.completedAt))[0];

                if (!stroopSession || !wmSession || !stroopSession.analysis.level2 || !wmSession.analysis.level2) {
                    return null;
                }

                const stroopL2 = stroopSession.analysis.level2;
                const wmL2 = wmSession.analysis.level2;
                const norms = NormativeData.CognitiveTrends;

                const combinedRT = (stroopL2.meanRT + wmL2.meanRT) / 2;
                const speedZ = (norms.Speed.mean - combinedRT) / norms.Speed.stdDev;
                let speedClass = 'Normal';
                if (speedZ < -1) speedClass = 'Abaixo do esperado';
                if (speedZ > 1) speedClass = 'Acima do esperado';

                const totalErrors = stroopL2.errors + wmL2.errors;
                let accuracyClass = 'Prejudicado';
                if (totalErrors <= norms.Accuracy.muitoAcima) accuracyClass = 'Muito acima do esperado';
                else if (totalErrors <= norms.Accuracy.acima) accuracyClass = 'Acima do esperado';
                else if (totalErrors <= norms.Accuracy.normal) accuracyClass = 'Normal';
                else if (totalErrors <= norms.Accuracy.abaixo) accuracyClass = 'Abaixo do esperado';

                const combinedStab = (stroopL2.stability + wmL2.stability) / 2;
                const stabZ = (norms.Stability.mean - combinedStab) / norms.Stability.stdDev;
                let stabClass = 'Normal';
                if (stabZ < -1) stabClass = 'Abaixo do esperado';
                if (stabZ > 1) stabClass = 'Acima do esperado';

                return {
                    speed: { zScore: speedZ.toFixed(2), classification: speedClass },
                    accuracy: { errors: totalErrors, classification: accuracyClass },
                    stability: { zScore: stabZ.toFixed(2), classification: stabClass }
                };
            }
        };
        
        // --- MOTOR DE SUGESTÕES ---
        const SuggestionEngine = {
            getIndividualSuggestions(testName, analysis) {
                const suggestions = [];
                const testSuggestions = this.definitions[testName];
                if (!testSuggestions || !analysis) return suggestions;

                const keyLevel = analysis.level2 || analysis.level1;
                if (!keyLevel) return suggestions;
                
                const thresholds = this.thresholds[testName];

                if (keyLevel.performanceIndex < thresholds.lowPerformanceIndex) {
                    suggestions.push(testSuggestions.lowPerformanceIndex);
                }
                if (testName === 'Go/No-Go') {
                    if (keyLevel.commissionErrors > thresholds.highCommissionErrors) {
                        suggestions.push(testSuggestions.highCommissionErrors);
                    }
                    if (keyLevel.omissionErrors > thresholds.highOmissionErrors) {
                        suggestions.push(testSuggestions.highOmissionErrors);
                    }
                }
                if (testName === 'Atenção Seletiva') {
                    if (analysis.stroopEffect > thresholds.highStroopEffect) {
                        suggestions.push(testSuggestions.highStroopEffect);
                    }
                }
                if (testName === 'Memória de Trabalho' || testName === 'Mapeamento Visual') {
                    if (keyLevel.accuracy < thresholds.lowAccuracy) {
                        suggestions.push(testSuggestions.lowAccuracy);
                    }
                }
                return [...new Set(suggestions.flat())];
            },

            generateGlobalPlan(sessions) {
                const allTestNames = ['Go/No-Go', 'Atenção Seletiva', 'Memória de Trabalho', 'Mapeamento Visual'];
                const latestSessions = {};
                allTestNames.forEach(testName => {
                    const testSessions = sessions
                        .filter(s => s.testName === testName && s.analysis && (s.analysis.level2 || s.analysis.level1))
                        .sort((a,b) => new Date(b.completedAt) - new Date(a.completedAt));
                    if (testSessions.length > 0) {
                        latestSessions[testName] = testSessions[0];
                    }
                });

                if (Object.keys(latestSessions).length < allTestNames.length) {
                     return {
                        title: 'Plano de Treino Global',
                        introduction: 'Para gerar um plano de treino global preciso, é necessário que o atleta complete todos os quatro testes cognitivos. Realize os testes restantes para obter sugestões personalizadas.',
                        priorityAreas: [],
                        otherAreas: []
                    };
                }

                const performanceScores = allTestNames.map(testName => {
                    const session = latestSessions[testName];
                    if (!session || !session.analysis) {
                        return { testName, score: 0 };
                    }
                    const keyLevel = session.analysis.level2 || session.analysis.level1;
                    return {
                        testName,
                        score: keyLevel ? keyLevel.performanceIndex : 0
                    };
                }).sort((a, b) => a.score - b.score);

                const priorityCutoff = 50;
                let prioritySuggestions = [];
                let otherSuggestions = [];

                performanceScores.forEach(({ testName, score }) => {
                    const session = latestSessions[testName];
                    if (session && session.analysis) {
                        const individualSuggestions = this.getIndividualSuggestions(testName, session.analysis);
                        if (score < priorityCutoff) {
                            prioritySuggestions.push(...individualSuggestions);
                        } else {
                            otherSuggestions.push(...individualSuggestions);
                        }
                    }
                });
                
                const uniquePriority = [...new Set(prioritySuggestions)];
                const uniqueOther = [...new Set(otherSuggestions)].filter(s => !uniquePriority.includes(s));

                return {
                    title: 'Plano de Treino Cognitivo Global',
                    introduction: 'Com base nos resultados mais recentes em todos os testes, identificamos as seguintes áreas prioritárias para desenvolvimento. Focar nestes exercícios ajudará a melhorar o desempenho geral do atleta.',
                    priorityAreas: uniquePriority,
                    otherAreas: uniqueOther
                };
            },
            thresholds: {
                'Go/No-Go': { lowPerformanceIndex: 50, highCommissionErrors: 2, highOmissionErrors: 3 },
                'Atenção Seletiva': { lowPerformanceIndex: 50, highStroopEffect: 200 },
                'Memória de Trabalho': { lowPerformanceIndex: 50, lowAccuracy: 85 },
                'Mapeamento Visual': { lowPerformanceIndex: 50, lowAccuracy: 85 }
            },
            definitions: {
                'Go/No-Go': {
                    highCommissionErrors: ['Controle Inibitório'],
                    highOmissionErrors: ['Atenção Sustentada'],
                    lowPerformanceIndex: ['Velocidade de Reação', 'Controle Inibitório']
                },
                'Atenção Seletiva': {
                    highStroopEffect: ['Flexibilidade Cognitiva'],
                    lowPerformanceIndex: ['Atenção Seletiva', 'Flexibilidade Cognitiva']
                },
                'Memória de Trabalho': {
                    lowAccuracy: ['Memória de Trabalho Visual']
                },
                'Mapeamento Visual': {
                    lowAccuracy: ['Rastreamento de Múltiplos Alvos']
                }
            },
            exercises: {
                'Controle Inibitório': {
                    title: 'Controle Inibitório',
                    description: 'Estes exercícios ajudam o atleta a resistir ao impulso de reagir a estímulos irrelevantes, uma habilidade crucial para evitar faltas e tomar decisões melhores sob pressão.',
                    activities: [
                        '**Treino de Sinais (Semáforo):** Use luzes ou coletes de cores diferentes (vermelho, amarelo, verde). O atleta só deve executar uma ação (ex: sprint) no sinal verde. Os sinais vermelho e amarelo são "No-Go" e exigem que o atleta iniba a resposta.',
                        '**Exercícios com Fintas:** Em treinos de 1x1 ou em grupo, o adversário ou treinador deve usar fintas e movimentos enganosos. O atleta deve focar no estímulo real (a bola, o quadril do oponente) e não reagir a movimentos falsos.',
                        '**Jogos de "Vivo ou Morto":** Uma versão esportiva do jogo clássico. O treinador dá comandos e o atleta só pode reagir aos comandos "válidos" previamente combinados, ignorando os demais.'
                    ]
                },
                'Atenção Sustentada': {
                    title: 'Atenção Sustentada',
                    description: 'Estes exercícios visam melhorar a capacidade do atleta de manter a concentração por períodos mais longos e garantir que ele não perca oportunidades por falta de atenção.',
                    activities: [
                        '**Exercícios de Reação Contínua:** O atleta deve reagir a uma série longa e monótona de estímulos (ex: tocar em cones que acendem), mantendo a performance do início ao fim.',
                        '**Treinos com Distrações Controladas:** Introduza distrações auditivas ou visuais (música, outros atletas se movendo) durante um exercício técnico. O atleta deve manter o foco na sua tarefa principal.',
                        '**Prática de Mindfulness e Foco na Respiração:** Ensine técnicas de respiração para que o atleta possa se "resetar" e voltar ao estado de foco durante pausas no jogo ou treino.'
                    ]
                },
                 'Velocidade de Reação': {
                    title: 'Velocidade de Reação',
                    description: 'Exercícios para diminuir o tempo entre o estímulo e a resposta motora, crucial para a maioria das ações esportivas.',
                    activities: [
                        '**Treino com Bolas de Reação:** Use bolas com superfícies irregulares que quicam de forma imprevisível. O atleta deve reagir e pegá-las.',
                        '**Sprints com Estímulo Sonoro/Visual:** O atleta inicia um sprint curto imediatamente após um estímulo (apito, luz, gesto). Varie o tipo de estímulo.',
                        '**Jogo de Cores e Toques:** Espalhe cones de cores diferentes. O treinador grita uma cor e o atleta deve correr e tocar no cone correspondente o mais rápido possível.'
                    ]
                },
                'Flexibilidade Cognitiva': {
                    title: 'Flexibilidade Cognitiva e Controle de Interferência',
                    description: 'Um alto Efeito Stroop indica dificuldade em ignorar informações conflitantes. Os treinos devem focar em forçar o cérebro a filtrar distrações e focar no que é relevante.',
                    activities: [
                        '**Exercícios com Coletes Trocados:** Atletas de um time usam coletes de uma cor, mas devem jogar como se fossem do time adversário. Isso cria uma interferência entre a informação visual (cor do colete) e a regra do jogo.',
                        '**Treinos com Múltiplas Instruções:** O treinador dá uma série de instruções verbais, mas o atleta só deve executar a que for associada a uma palavra-chave específica. As outras devem ser ignoradas.',
                        '**Jogos de Tomada de Decisão com Informação Incongruente:** Use cartas ou aplicativos que mostrem palavras de cores em cores diferentes (similar ao teste Stroop) e peça para o atleta nomear a cor da "tinta" o mais rápido possível.'
                    ]
                },
                'Atenção Seletiva': {
                    title: 'Atenção Seletiva',
                    description: 'Um baixo índice geral neste teste sugere uma dificuldade em manter o foco em meio a distrações. Os exercícios devem simular o ambiente caótico de um jogo.',
                    activities: [
                        '**Treinos em Ambientes Ruidosos:** Realize treinos técnicos importantes com som ambiente de torcida ou música alta para acostumar o atleta a filtrar ruídos.',
                        '**Exercícios de "Visão de Túnel":** O atleta deve executar uma tarefa (ex: driblar uma bola) enquanto foca em um ponto fixo à sua frente, usando a visão periférica para navegar.',
                        '**Jogos com "Jogadores-Sombra":** Um ou mais jogadores extras (sem função tática real) se movem pelo campo para criar distração visual, e os atletas em jogo devem ignorá-los.'
                    ]
                },
                'Memória de Trabalho Visual': {
                    title: 'Memória de Trabalho Visual',
                    description: 'A memória de trabalho é essencial para lembrar de jogadas, posicionamento de companheiros e adversários. Estes exercícios ajudam a "expandir" essa capacidade.',
                    activities: [
                        '**Memorização de Padrões Táticos:** Mostre ao atleta um padrão tático em um quadro por 5-10 segundos. Em seguida, ele deve replicar o posicionamento dos jogadores em um mini-campo.',
                        '**Jogo da Memória com Exercícios:** Use cones coloridos. Crie uma sequência de cores e o atleta deve repeti-la. Aumente a dificuldade adicionando mais cores à sequência.',
                        '**Repetição de Sequências de Movimento:** O treinador executa uma sequência de 3-4 movimentos (ex: pique, salto, rolamento). O atleta deve observar e repetir a sequência exatamente na mesma ordem.'
                    ]
                },
                'Rastreamento de Múltiplos Alvos': {
                    title: 'Rastreamento de Múltiplos Alvos',
                    description: 'Essencial em esportes coletivos para acompanhar companheiros e adversários simultaneamente. O objetivo é ampliar o campo de atenção e a capacidade de processar múltiplos objetos em movimento.',
                    activities: [
                        '**Exercícios com Bolas de Cores Diferentes:** Em um exercício de passe, use bolas de várias cores. O atleta só pode interagir com a bola da cor que o treinador anunciar. Todas as bolas estão em movimento, forçando o rastreamento múltiplo.',
                        '**"Bobinho" com Alvos Definidos:** No tradicional jogo do "bobinho", os jogadores de fora devem passar a bola apenas para 2 ou 3 "alvos" específicos, que também estão se movendo. O defensor deve tentar interceptar, rastreando tanto a bola quanto os alvos.',
                        '**Uso de Óculos Estroboscópicos:** Estes óculos piscam, bloqueando a visão intermitentemente. Fazer treinos técnicos simples com eles força o cérebro a prever a trajetória de objetos e a preencher as "lacunas" visuais.'
                    ]
                }
            }
        };

        // --- GERENCIADOR DE UI ---
        const UI = {
            views: {},
            modal: null, reportModal: null, globalSuggestionsModal: null,
            modalTitle: null, athleteForm: null, athleteList: null,
            athleteProfileContent: null, testContent: null,

            init() {
                this.views = {
                    dashboard: document.getElementById('dashboard-view'),
                    profile: document.getElementById('profile-view'),
                    testRunner: document.getElementById('test-runner-view'),
                };
                this.modal = document.getElementById('athlete-modal');
                this.reportModal = document.getElementById('report-modal');
                this.globalSuggestionsModal = document.getElementById('global-suggestions-modal');
                this.modalTitle = document.getElementById('modal-title');
                this.athleteForm = document.getElementById('athlete-form');
                this.athleteList = document.getElementById('athlete-list');
                this.athleteProfileContent = document.getElementById('athlete-profile-content');
                this.testContent = document.getElementById('test-content');
            },

            showView(viewName) { Object.values(this.views).forEach(v => v.classList.remove('active')); if (this.views[viewName]) this.views[viewName].classList.add('active'); },
            openModal(athlete = null) { this.athleteForm.reset(); this.modalTitle.textContent = athlete ? 'Editar Atleta' : 'Adicionar Novo Atleta'; document.getElementById('athlete-id').value = athlete ? athlete.id : ''; if(athlete){ Object.keys(athlete).forEach(key => { const el = document.getElementById(key); if(el) el.value = athlete[key]; }); } this.modal.classList.remove('hidden'); this.modal.classList.add('flex'); },
            closeModal() { this.modal.classList.add('hidden'); this.modal.classList.remove('flex'); },
            enterFullscreen() {
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen().catch(err => {
                        console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                    });
                }
            },
            exitFullscreen() {
                if (document.exitFullscreen && document.fullscreenElement) {
                    document.exitFullscreen();
                }
            },
            getPerformanceColor(index, type = 'bg') {
                const value = Number(index);
                if (value >= 60) return type === 'bg' ? 'bg-green-500' : 'text-green-600';
                if (value >= 41) return type === 'bg' ? 'bg-yellow-500' : 'text-yellow-600';
                return type === 'bg' ? 'bg-red-500' : 'text-red-600';
            },
            renderAthleteList(athletes) { if (!this.athleteList) return; if (athletes.length === 0) { this.athleteList.innerHTML = '<p class="text-gray-500">Nenhum atleta cadastrado. Adicione um para começar.</p>'; return; } this.athleteList.innerHTML = `<table class="w-full text-left"><thead><tr class="border-b"><th class="p-4">Nome</th><th class="p-4 hidden sm:table-cell">Idade</th><th class="p-4 hidden md:table-cell">Esporte</th><th class="p-4">Ações</th></tr></thead><tbody>${athletes.map(a => `<tr class="border-b hover:bg-gray-50"><td class="p-4 font-medium">${a.name}</td><td class="p-4 hidden sm:table-cell">${getAge(a.dob)}</td><td class="p-4 hidden md:table-cell">${a.sport}</td><td class="p-4"><button class="view-btn text-blue-600 hover:text-blue-800 mr-4" data-id="${a.id}"><i class="fas fa-eye"></i></button><button class="edit-btn text-yellow-600 hover:text-yellow-800 mr-4" data-id="${a.id}"><i class="fas fa-pencil-alt"></i></button><button class="delete-btn text-red-600 hover:text-red-800" data-id="${a.id}"><i class="fas fa-trash"></i></button></td></tr>`).join('')}</tbody></table>`; },
            renderAthleteProfile(athlete, sessions) { 
                this.athleteProfileContent.dataset.currentAthleteId = athlete.id;

                const testButtonsHtml = `
                    <div>
                        <button data-testid="start-gong-test" class="w-full text-left p-4 bg-blue-500 text-white rounded-lg shadow hover:bg-blue-600 transition flex items-center justify-between">
                            <span>Teste de Reação e Inibição (Go/No-Go)</span><i class="fas fa-play"></i>
                        </button>
                        <p class="text-sm text-gray-500 mt-1 px-1">Avalia a velocidade de reação a um estímulo e a capacidade de inibir uma resposta.</p>
                    </div>
                    <div>
                        <button data-testid="start-stroop-test" class="w-full text-left p-4 bg-purple-500 text-white rounded-lg shadow hover:bg-purple-600 transition flex items-center justify-between">
                            <span>Teste de Atenção Seletiva (Stroop)</span><i class="fas fa-play"></i>
                        </button>
                        <p class="text-sm text-gray-500 mt-1 px-1">Mede a capacidade de focar em uma informação específica enquanto ignora distrações.</p>
                    </div>
                    <div>
                        <button data-testid="start-wm-test" class="w-full text-left p-4 bg-teal-500 text-white rounded-lg shadow hover:bg-teal-600 transition flex items-center justify-between">
                            <span>Teste de Memória de Trabalho</span><i class="fas fa-play"></i>
                        </button>
                        <p class="text-sm text-gray-500 mt-1 px-1">Testa a habilidade de memorizar e manipular informações visuais por um curto período.</p>
                    </div>
                    <div>
                        <button data-testid="start-vm-test" class="w-full text-left p-4 bg-orange-500 text-white rounded-lg shadow hover:bg-orange-600 transition flex items-center justify-between">
                            <span>Teste de Mapeamento Visual</span><i class="fas fa-play"></i>
                        </button>
                        <p class="text-sm text-gray-500 mt-1 px-1">Avalia a capacidade de rastrear múltiplos objetos em movimento simultaneamente.</p>
                    </div>
                `;

                this.athleteProfileContent.innerHTML = `
                    <div class="mb-8">
                        <h2 class="text-3xl font-bold">${athlete.name}</h2>
                        <p class="text-gray-600 mt-1">${athlete.sport} | ${getAge(athlete.dob)} anos | ${athlete.gender}</p>
                    </div>
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                        <div>
                            <h3 class="text-xl font-semibold border-b pb-2 mb-4">Testes Disponíveis</h3>
                            <div class="space-y-4">${testButtonsHtml}</div>
                             <div class="mt-6">
                                <button id="generate-global-plan-btn" class="w-full p-4 bg-green-600 text-white rounded-lg shadow hover:bg-green-700 transition flex items-center justify-center text-lg">
                                    <i class="fas fa-cogs mr-3"></i> Gerar Plano de Treino
                                </button>
                            </div>
                        </div>
                        <div>
                            <h3 class="text-xl font-semibold border-b pb-2 mb-4">Histórico de Avaliações</h3>
                            <div id="session-history">${this.renderSessionHistory(sessions)}</div>
                        </div>
                    </div>
                    <div class="mt-8 pt-6 border-t grid grid-cols-1 xl:grid-cols-2 gap-8">
                        ${this.renderPerformanceSummary(sessions)}
                        ${this.renderCognitiveTrends(sessions)}
                    </div>
                    `; 
            },
            renderSessionHistory(sessions) { if (sessions.length === 0) return '<p class="text-gray-500">Nenhuma avaliação realizada.</p>'; return `<ul class="space-y-3">${sessions.sort((a,b) => new Date(b.completedAt) - new Date(a.completedAt)).map((s, i) => `<li class="p-3 bg-gray-50 rounded-md flex justify-between items-center"><div><span class="font-semibold">${s.testName}</span> - <span class="text-gray-600">${new Date(s.completedAt).toLocaleString('pt-BR')}</span></div><div class="flex items-center"><button class="view-report-btn px-3 py-1 bg-white border border-gray-300 text-sm rounded-md hover:bg-gray-100 mr-3" data-session-index="${i}">Ver Relatório</button><button class="delete-report-btn text-red-500 hover:text-red-700" data-session-index="${i}"><i class="fas fa-trash"></i></button></div></li>`).join('')}</ul>`; },
            renderPerformanceSummary(sessions) {
                const latestSessions = {};
                ['Go/No-Go', 'Atenção Seletiva', 'Memória de Trabalho', 'Mapeamento Visual'].forEach(testName => {
                    const testSessions = sessions
                        .filter(s => s.testName === testName && s.analysis && (s.analysis.level2 || s.analysis.level1))
                        .sort((a,b) => new Date(b.completedAt) - new Date(a.completedAt));
                    if (testSessions.length > 0) {
                        latestSessions[testName] = testSessions[0];
                    }
                });

                const indices = Object.values(latestSessions).map(s => {
                    const keyLevel = s.analysis.level2 || s.analysis.level1;
                    return (keyLevel && typeof keyLevel.performanceIndex === 'number') ? keyLevel.performanceIndex : null;
                }).filter(val => typeof val === 'number');

                const generalIndex = indices.length > 0 ? indices.reduce((a, b) => a + b, 0) / indices.length : 0;

                const barsHtml = Object.keys(NormativeData).filter(k => k !== 'CognitiveTrends').map(testName => {
                    const session = latestSessions[testName];
                    let index2 = 0;
                    let index3 = 0;
                    let displayIndex2 = 'N/A';
                    let displayIndex3 = 'N/A';
                    if (session) {
                        const keyLevel2 = session.analysis.level2;
                        const keyLevel3 = session.analysis.level3;
                        if (keyLevel2 && typeof keyLevel2.performanceIndex === 'number') {
                            index2 = keyLevel2.performanceIndex;
                            displayIndex2 = index2.toFixed(0);
                        }
                        if (keyLevel3 && typeof keyLevel3.performanceIndex === 'number') {
                            index3 = keyLevel3.performanceIndex;
                            displayIndex3 = index3.toFixed(0);
                        }
                    }
                    const colorClass2 = this.getPerformanceColor(index2);
                    const colorClass3 = this.getPerformanceColor(index3);

                    return `
                    <div class="grid grid-cols-4 items-center gap-2">
                        <p class="text-sm font-medium text-gray-700 col-span-1">${testName}</p>
                        <div class="col-span-3 space-y-1">
                            <div class="performance-bar-container">
                                <div class="performance-bar ${colorClass2}" style="width: ${index2.toFixed(0)}%;">${displayIndex2} (N2)</div>
                            </div>
                            <div class="performance-bar-container">
                                <div class="performance-bar ${colorClass3}" style="width: ${index3.toFixed(0)}%;">${displayIndex3} (N3)</div>
                            </div>
                        </div>
                    </div>`;
                }).join('');

                return `
                    <div>
                        <h3 class="text-xl font-semibold mb-2">Visão Geral do Desempenho</h3>
                        <div class="flex flex-col gap-4 mb-6 bg-gray-50 p-4 rounded-lg">
                            <div class="flex items-center gap-4">
                                <div class="text-center w-1/4">
                                    <p class="text-sm font-medium text-gray-600">Desempenho Geral</p>
                                    <p class="text-4xl font-bold ${this.getPerformanceColor(generalIndex, 'text')}">${generalIndex > 0 ? generalIndex.toFixed(0) : 'N/A'}</p>
                                </div>
                                <div class="flex-grow space-y-3 w-3/4">
                                    ${barsHtml || '<p class="text-gray-500">Realize os testes para ver o resumo de desempenho.</p>'}
                                </div>
                            </div>
                            <div class="mt-2 flex justify-center items-center space-x-4 text-xs text-gray-600 border-t pt-3">
                                <div class="flex items-center"><span class="h-3 w-3 rounded-full bg-red-500 mr-2"></span> 0-40 (Abaixo da média)</div>
                                <div class="flex items-center"><span class="h-3 w-3 rounded-full bg-yellow-500 mr-2"></span> 41-59 (Na média)</div>
                                <div class="flex items-center"><span class="h-3 w-3 rounded-full bg-green-500 mr-2"></span> 60-100 (Acima da média)</div>
                            </div>
                        </div>
                    </div>
                `;
            },
            renderCognitiveTrends(sessions) {
                const trends = Analysis.analyzeCognitiveTrends(sessions);
                let content;

                if (!trends) {
                    content = `<div class="bg-gray-50 p-4 rounded-lg"><p class="text-gray-500">Realize os testes de Atenção Seletiva e Memória de Trabalho para ver as tendências.</p></div>`;
                } else {
                    content = `
                        <div class="bg-gray-50 p-4 rounded-lg space-y-3">
                            <table class="w-full text-sm">
                                <thead>
                                    <tr class="border-b">
                                        <th class="text-left p-2">Indicador</th>
                                        <th class="text-center p-2">Classificação</th>
                                        <th class="text-right p-2">Escore</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr class="border-b">
                                        <td class="p-2 font-medium">Velocidade</td>
                                        <td class="text-center p-2">${trends.speed.classification}</td>
                                        <td class="text-right p-2">${trends.speed.zScore} <span class="text-gray-500">(z)</span></td>
                                    </tr>
                                    <tr class="border-b">
                                        <td class="p-2 font-medium">Acurácia</td>
                                        <td class="text-center p-2">${trends.accuracy.classification}</td>
                                        <td class="text-right p-2">${trends.accuracy.errors} <span class="text-gray-500">(erros)</span></td>
                                    </tr>
                                    <tr>
                                        <td class="p-2 font-medium">Estabilidade</td>
                                        <td class="text-center p-2">${trends.stability.classification}</td>
                                        <td class="text-right p-2">${trends.stability.zScore} <span class="text-gray-500">(z)</span></td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="mt-4 text-xs text-gray-600 space-y-2">
                            <p><strong>Velocidade:</strong> Média do tempo de resposta. Um escore-z positivo indica velocidade acima da média.</p>
                            <p><strong>Acurácia:</strong> Total de erros. Uma classificação melhor indica menos erros cometidos.</p>
                            <p><strong>Estabilidade:</strong> Consistência no tempo de resposta. Um escore-z positivo indica maior consistência, o que é desejável.</p>
                        </div>
                    `;
                }
                
                return `
                    <div>
                        <h3 class="text-xl font-semibold mb-2">Tendências Cognitivas</h3>
                        ${content}
                    </div>
                `;
            },
            openReportModal(session, athleteId) {
                const reportContentEl = document.getElementById('report-content');

                if (session.analysis && session.levelData && (!session.analysis.level1 || typeof session.analysis.level1.performanceIndex === 'undefined')) {
                    console.log("Sessão antiga detectada. Reanalisando para gerar o Índice de Desempenho...");
                    let reanalyzed;
                    if (session.testName === 'Go/No-Go') reanalyzed = Analysis.analyzeGoNoGoResults(session.levelData);
                    else if (session.testName === 'Atenção Seletiva') reanalyzed = Analysis.analyzeStroopResults(session.levelData);
                    else if (session.testName === 'Memória de Trabalho') reanalyzed = Analysis.analyzeWorkingMemoryResults(session.levelData);
                    else if (session.testName === 'Mapeamento Visual') reanalyzed = Analysis.analyzeVisualMappingResults(session.levelData);
                    
                    if (reanalyzed) {
                        session.analysis = reanalyzed;
                        AppData.updateSessionByTimestamp(athleteId, session.completedAt, session);
                    }
                }

                if (!session.analysis || !session.analysis.level1) {
                    reportContentEl.innerHTML = `<h3 class="text-2xl font-bold mb-4">Erro ao Carregar Relatório</h3><p>Os dados de análise para esta sessão não foram encontrados ou estão corrompidos. Por favor, realize o teste novamente.</p>`;
                } else if (session.testName === 'Go/No-Go') {
                    reportContentEl.innerHTML = this.renderGoNoGoReport(session);
                } else if (session.testName === 'Atenção Seletiva') {
                    reportContentEl.innerHTML = this.renderStroopReport(session);
                } else if (session.testName === 'Memória de Trabalho') {
                    reportContentEl.innerHTML = this.renderWorkingMemoryReport(session);
                } else if (session.testName === 'Mapeamento Visual') {
                    reportContentEl.innerHTML = this.renderVisualMappingReport(session);
                }
                
                this.reportModal.classList.remove('hidden');
                this.reportModal.classList.add('flex');
            },
            openGlobalSuggestionsModal(plan) {
                const container = document.getElementById('global-suggestions-content');
                
                const renderExercises = (area) => {
                    const exerciseData = SuggestionEngine.exercises[area];
                    if (!exerciseData) return '';
                    return `
                        <div class="mb-6">
                            <h4 class="text-lg font-bold text-gray-800">${exerciseData.title}</h4>
                            <p class="text-sm text-gray-600 mt-1 mb-3">${exerciseData.description}</p>
                            <ul class="list-disc list-inside space-y-2 text-gray-700">
                                ${exerciseData.activities.map(act => `<li>${act.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                };

                let contentHtml = `<h3 class="text-2xl font-bold mb-4">${plan.title}</h3><p class="mb-6">${plan.introduction}</p>`;

                if (plan.priorityAreas.length > 0) {
                    contentHtml += '<h4 class="text-xl font-semibold mb-4 border-b pb-2 text-red-600">Áreas Prioritárias</h4>';
                    contentHtml += plan.priorityAreas.map(renderExercises).join('');
                }
                
                if (plan.otherAreas.length > 0) {
                    contentHtml += '<h4 class="text-xl font-semibold mt-8 mb-4 border-b pb-2 text-green-600">Outras Áreas para Desenvolvimento</h4>';
                    contentHtml += plan.otherAreas.map(renderExercises).join('');
                }

                container.innerHTML = contentHtml;
                this.globalSuggestionsModal.classList.remove('hidden');
                this.globalSuggestionsModal.classList.add('flex');
            },
            closeGlobalSuggestionsModal() {
                this.globalSuggestionsModal.classList.add('hidden');
                this.globalSuggestionsModal.classList.remove('flex');
            },
            renderIndexLegend() {
                return `
                <div class="mt-2 mb-6 p-3 bg-gray-100 rounded-lg text-sm text-gray-600">
                    <p>O <strong>Índice de Desempenho</strong> é uma pontuação de 0 a 100 que combina velocidade e precisão, comparando o resultado com uma média populacional. <strong>50</strong> é a média, valores acima são melhores.</p>
                </div>
                `;
            },
            getPerformanceChangeText(delta, performanceIndex2) {
                if (delta === undefined || delta === null) return '';
                
                const absDelta = Math.abs(delta);
                let changeText = '';
                let changeClass = '';
                
                if (absDelta <= 5) {
                    changeText = 'Manteve o desempenho';
                    changeClass = 'delta-neutral';
                } else if (delta < -5) {
                    const base = performanceIndex2 !== 0 ? performanceIndex2 : 1;
                    const percent = Math.abs(delta / base) * 100;
                    changeText = `Queda de ${Math.max(1, Math.round(percent))}% no desempenho`;
                    changeClass = 'delta-positive';
                } else {
                    const base = performanceIndex2 !== 0 ? performanceIndex2 : 1;
                    const percent = Math.abs(delta / base) * 100;
                    changeText = `Melhora de ${Math.max(1, Math.round(percent))}% no desempenho`;
                    changeClass = 'delta-negative';
                }
                
                return `<span class="${changeClass}">${changeText}</span>`;
            },
            renderGoNoGoReport(session) { 
                const analysis = session.analysis; 
                const formatDelta = (value, unit = '', higherIsWorse = true) => { 
                    const isWorse = higherIsWorse ? value > 0 : value < 0; 
                    const isBetter = higherIsWorse ? value < 0 : value > 0; 
                    const colorClass = isWorse ? 'delta-positive' : (isBetter ? 'delta-negative' : 'delta-neutral'); 
                    const sign = value >= 0 ? '+' : ''; 
                    return `<span class="${colorClass}">${sign}${value.toFixed(0)}${unit}</span>`; 
                }; 
                const perfIndex2 = analysis?.level2?.performanceIndex?.toFixed(0) ?? 'N/A';
                const perfIndex3 = analysis?.level3?.performanceIndex?.toFixed(0) ?? 'N/A';
                const perfDelta = analysis?.delta?.performanceIndex ?? 0;
                const perfChangeText = this.getPerformanceChangeText(perfDelta, perfIndex2);

                return `<h3 class="text-2xl font-bold mb-2">Relatório de Desempenho - ${session.testName}</h3>
                <p class="text-gray-600 mb-4">Realizado em: ${new Date(session.completedAt).toLocaleString('pt-BR')}</p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    <div class="p-4 bg-blue-50 rounded-lg">
                        <p class="text-center font-semibold">Índice de Desempenho (Nível Padrão): <span class="text-2xl font-bold ${this.getPerformanceColor(perfIndex2, 'text')}">${perfIndex2}</span></p>
                    </div>
                    <div class="p-4 bg-blue-100 rounded-lg">
                        <p class="text-center font-semibold">Índice Sob Pressão (Nível 3): <span class="text-2xl font-bold ${this.getPerformanceColor(perfIndex3, 'text')}">${perfIndex3}</span></p>
                        <p class="text-center mt-2">${perfChangeText}</p>
                    </div>
                </div>
                ${this.renderIndexLegend()}
                <table class="w-full text-left border-collapse">
                <thead><tr class="bg-gray-100"><th class="p-3 border-b">Métrica</th><th class="p-3 border-b text-center">Nível 1</th><th class="p-3 border-b text-center">Nível 2</th><th class="p-3 border-b text-center">Nível 3 (Pressão)</th><th class="p-3 border-b text-center">Efeito Sob Pressão (N3-N2)</th></tr></thead>
                <tbody>
                    <tr><td class="p-3 font-medium border-b">Tempo Médio (ms)<p class="text-xs text-gray-500 italic font-normal">Velocidade de resposta.</p></td><td class="p-3 text-center border-b">${analysis.level1.meanRT.toFixed(0)}</td><td class="p-3 text-center border-b">${analysis.level2.meanRT.toFixed(0)}</td><td class="p-3 text-center border-b">${analysis.level3.meanRT.toFixed(0)}</td><td class="p-3 text-center border-b font-bold">${analysis.delta ? formatDelta(analysis.delta.meanRT, 'ms') : '-'}</td></tr>
                    <tr><td class="p-3 font-medium border-b">Estabilidade (CV%)<p class="text-xs text-gray-500 italic font-normal">Consistência do tempo de resposta.</p></td><td class="p-3 text-center border-b">${analysis.level1.stability.toFixed(2)}</td><td class="p-3 text-center border-b">${analysis.level2.stability.toFixed(2)}</td><td class="p-3 text-center border-b">${analysis.level3.stability.toFixed(2)}</td><td class="p-3 text-center border-b font-bold">${analysis.delta ? formatDelta(analysis.delta.stability, '%') : '-'}</td></tr>
                    <tr><td class="p-3 font-medium border-b">Acurácia (%)<p class="text-xs text-gray-500 italic font-normal">Percentual de acertos.</p></td><td class="p-3 text-center border-b">${analysis.level1.accuracy.toFixed(2)}</td><td class="p-3 text-center border-b">${analysis.level2.accuracy.toFixed(2)}</td><td class="p-3 text-center border-b">${analysis.level3.accuracy.toFixed(2)}</td><td class="p-3 text-center border-b font-bold">${analysis.delta ? formatDelta(analysis.delta.accuracy, '%', false) : '-'}</td></tr>
                    <tr><td class="p-3 font-medium border-b">Erros de Comissão<p class="text-xs text-gray-500 italic font-normal">Cliques em estímulos 'No-Go'.</p></td><td class="p-3 text-center border-b">${analysis.level1.commissionErrors}</td><td class="p-3 text-center border-b">${analysis.level2.commissionErrors}</td><td class="p-3 text-center border-b">${analysis.level3.commissionErrors}</td><td class="p-3 text-center border-b font-bold">${analysis.delta ? formatDelta(analysis.delta.commissionErrors, '') : '-'}</td></tr>
                    <tr><td class="p-3 font-medium">Erros de Omissão<p class="text-xs text-gray-500 italic font-normal">Falta de clique em estímulos 'Go'.</p></td><td class="p-3 text-center">${analysis.level1.omissionErrors}</td><td class="p-3 text-center">${analysis.level2.omissionErrors}</td><td class="p-3 text-center">${analysis.level3.omissionErrors}</td><td class="p-3 text-center font-bold">${analysis.delta ? formatDelta(analysis.delta.omissionErrors, '') : '-'}</td></tr>
                </tbody></table>`; 
            },
            renderStroopReport(session) { 
                const analysis = session.analysis; 
                const formatDelta = (value, unit = '', higherIsWorse = true) => { 
                    const isWorse = higherIsWorse ? value > 0 : value < 0; 
                    const isBetter = higherIsWorse ? value < 0 : value > 0; 
                    const colorClass = isWorse ? 'delta-positive' : (isBetter ? 'delta-negative' : 'delta-neutral'); 
                    const sign = value >= 0 ? '+' : ''; 
                    return `<span class="${colorClass}">${sign}${value.toFixed(0)}${unit}</span>`; 
                }; 
                const perfIndex2 = analysis?.level2?.performanceIndex?.toFixed(0) ?? 'N/A';
                const perfIndex3 = analysis?.level3?.performanceIndex?.toFixed(0) ?? 'N/A';
                const perfDelta = analysis?.pressureEffect?.performanceIndex ?? 0;
                const perfChangeText = this.getPerformanceChangeText(perfDelta, perfIndex2);

                return `<h3 class="text-2xl font-bold mb-2">Relatório de Desempenho - ${session.testName}</h3>
                <p class="text-gray-600 mb-4">Realizado em: ${new Date(session.completedAt).toLocaleString('pt-BR')}</p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    <div class="p-4 bg-purple-50 rounded-lg">
                        <p class="text-center font-semibold">Índice de Desempenho (Nível Padrão): <span class="text-2xl font-bold ${this.getPerformanceColor(perfIndex2, 'text')}">${perfIndex2}</span></p>
                    </div>
                    <div class="p-4 bg-purple-100 rounded-lg">
                        <p class="text-center font-semibold">Índice Sob Pressão (Nível 3): <span class="text-2xl font-bold ${this.getPerformanceColor(perfIndex3, 'text')}">${perfIndex3}</span></p>
                        <p class="text-center mt-2">${perfChangeText}</p>
                    </div>
                </div>
                ${this.renderIndexLegend()}
                <div class="mb-4 p-4 bg-blue-50 rounded-lg"><p class="text-center font-semibold">Efeito Stroop (N2 - N1): <span class="text-xl">${analysis.stroopEffect ? analysis.stroopEffect.toFixed(0) : 'N/A'} ms</span></p></div>
                <table class="w-full text-left border-collapse">
                <thead><tr class="bg-gray-100"><th class="p-3 border-b">Métrica</th><th class="p-3 border-b text-center">Nível 1 (Congruente)</th><th class="p-3 border-b text-center">Nível 2 (Incongruente)</th><th class="p-3 border-b text-center">Nível 3 (Pressão)</th><th class="p-3 border-b text-center">Efeito Sob Pressão (N3-N2)</th></tr></thead>
                <tbody>
                    <tr><td class="p-3 font-medium border-b">Tempo Médio (ms)<p class="text-xs text-gray-500 italic font-normal">Velocidade de resposta.</p></td><td class="p-3 text-center border-b">${analysis.level1.meanRT.toFixed(0)}</td><td class="p-3 text-center border-b">${analysis.level2.meanRT.toFixed(0)}</td><td class="p-3 text-center border-b">${analysis.level3.meanRT.toFixed(0)}</td><td class="p-3 text-center border-b font-bold">${analysis.pressureEffect ? formatDelta(analysis.pressureEffect.meanRT, 'ms') : '-'}</td></tr>
                    <tr><td class="p-3 font-medium border-b">Estabilidade (CV%)<p class="text-xs text-gray-500 italic font-normal">Consistência da resposta.</p></td><td class="p-3 text-center border-b">${analysis.level1.stability.toFixed(2)}</td><td class="p-3 text-center border-b">${analysis.level2.stability.toFixed(2)}</td><td class="p-3 text-center border-b">${analysis.level3.stability.toFixed(2)}</td><td class="p-3 text-center border-b font-bold">${analysis.pressureEffect ? formatDelta(analysis.pressureEffect.stability, '%') : '-'}</td></tr>
                    <tr><td class="p-3 font-medium border-b">Acurácia (%)<p class="text-xs text-gray-500 italic font-normal">Percentual de acertos.</p></td><td class="p-3 text-center border-b">${analysis.level1.accuracy.toFixed(2)}</td><td class="p-3 text-center border-b">${analysis.level2.accuracy.toFixed(2)}</td><td class="p-3 text-center border-b">${analysis.level3.accuracy.toFixed(2)}</td><td class="p-3 text-center border-b font-bold">${analysis.pressureEffect ? formatDelta(analysis.pressureEffect.accuracy, '%', false) : '-'}</td></tr>
                    <tr><td class="p-3 font-medium">Erros<p class="text-xs text-gray-500 italic font-normal">Número de respostas incorretas.</p></td><td class="p-3 text-center">${analysis.level1.errors}</td><td class="p-3 text-center">${analysis.level2.errors}</td><td class="p-3 text-center">${analysis.level3.errors}</td><td class="p-3 text-center font-bold">${analysis.pressureEffect ? formatDelta(analysis.pressureEffect.errors, '') : '-'}</td></tr>
                </tbody></table>`; 
            },
            renderWorkingMemoryReport(session) { 
                const analysis = session.analysis; 
                const formatDelta = (value, unit = '', higherIsWorse = true) => { 
                    const isWorse = higherIsWorse ? value > 0 : value < 0; 
                    const isBetter = higherIsWorse ? value < 0 : value > 0; 
                    const colorClass = isWorse ? 'delta-positive' : (isBetter ? 'delta-negative' : 'delta-neutral'); 
                    const sign = value >= 0 ? '+' : ''; 
                    return `<span class="${colorClass}">${sign}${value.toFixed(0)}${unit}</span>`; 
                };
                const perfIndex2 = analysis?.level2?.performanceIndex?.toFixed(0) ?? 'N/A';
                const perfIndex3 = analysis?.level3?.performanceIndex?.toFixed(0) ?? 'N/A';
                const perfDelta = analysis?.pressureEffect?.performanceIndex ?? 0;
                const perfChangeText = this.getPerformanceChangeText(perfDelta, perfIndex2);

                return `<h3 class="text-2xl font-bold mb-4">Relatório de Desempenho - ${session.testName}</h3>
                <p class="text-gray-600 mb-6">Realizado em: ${new Date(session.completedAt).toLocaleString('pt-BR')}</p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    <div class="p-4 bg-teal-50 rounded-lg">
                        <p class="text-center font-semibold">Índice de Desempenho (Nível Padrão): <span class="text-2xl font-bold ${this.getPerformanceColor(perfIndex2, 'text')}">${perfIndex2}</span></p>
                    </div>
                    <div class="p-4 bg-teal-100 rounded-lg">
                        <p class="text-center font-semibold">Índice Sob Pressão (Nível 3): <span class="text-2xl font-bold ${this.getPerformanceColor(perfIndex3, 'text')}">${perfIndex3}</span></p>
                        <p class="text-center mt-2">${perfChangeText}</p>
                    </div>
                </div>
                ${this.renderIndexLegend()}
                <table class="w-full text-left border-collapse">
                <thead><tr class="bg-gray-100"><th class="p-3 border-b">Métrica</th><th class="p-3 border-b text-center">Nível 1 (3 itens)</th><th class="p-3 border-b text-center">Nível 2 (4 itens)</th><th class="p-3 border-b text-center">Nível 3 (Pressão)</th><th class="p-3 border-b text-center">Efeito Sob Pressão (N3-N2)</th></tr></thead>
                <tbody>
                    <tr><td class="p-3 font-medium border-b">Tempo Médio (ms)<p class="text-xs text-gray-500 italic font-normal">Velocidade de resposta.</p></td><td class="p-3 text-center border-b">${analysis.level1.meanRT.toFixed(0)}</td><td class="p-3 text-center border-b">${analysis.level2.meanRT.toFixed(0)}</td><td class="p-3 text-center border-b">${analysis.level3.meanRT.toFixed(0)}</td><td class="p-3 text-center border-b font-bold">${analysis.pressureEffect ? formatDelta(analysis.pressureEffect.meanRT, 'ms') : '-'}</td></tr>
                    <tr><td class="p-3 font-medium border-b">Estabilidade (CV%)<p class="text-xs text-gray-500 italic font-normal">Consistência da resposta.</p></td><td class="p-3 text-center border-b">${analysis.level1.stability.toFixed(2)}</td><td class="p-3 text-center border-b">${analysis.level2.stability.toFixed(2)}</td><td class="p-3 text-center border-b">${analysis.level3.stability.toFixed(2)}</td><td class="p-3 text-center border-b font-bold">${analysis.pressureEffect ? formatDelta(analysis.pressureEffect.stability, '%') : '-'}</td></tr>
                    <tr><td class="p-3 font-medium border-b">Acurácia (%)<p class="text-xs text-gray-500 italic font-normal">Percentual de acertos.</p></td><td class="p-3 text-center border-b">${analysis.level1.accuracy.toFixed(2)}</td><td class="p-3 text-center border-b">${analysis.level2.accuracy.toFixed(2)}</td><td class="p-3 text-center border-b">${analysis.level3.accuracy.toFixed(2)}</td><td class="p-3 text-center border-b font-bold">${analysis.pressureEffect ? formatDelta(analysis.pressureEffect.accuracy, '%', false) : '-'}</td></tr>
                    <tr><td class="p-3 font-medium">Erros<p class="text-xs text-gray-500 italic font-normal">Número de tentativas incorretas.</p></td><td class="p-3 text-center">${analysis.level1.errors}</td><td class="p-3 text-center">${analysis.level2.errors}</td><td class="p-3 text-center">${analysis.level3.errors}</td><td class="p-3 text-center font-bold">${analysis.pressureEffect ? formatDelta(analysis.pressureEffect.errors, '') : '-'}</td></tr>
                </tbody></table>`; 
            },
            renderVisualMappingReport(session) {
                const analysis = session.analysis;
                const formatDelta = (value, unit = '', higherIsWorse = true) => { 
                    const isWorse = higherIsWorse ? value > 0 : value < 0; 
                    const isBetter = higherIsWorse ? value < 0 : value > 0; 
                    const colorClass = isWorse ? 'delta-positive' : (isBetter ? 'delta-negative' : 'delta-neutral'); 
                    const sign = value >= 0 ? '+' : ''; 
                    return `<span class="${colorClass}">${sign}${value.toFixed(0)}${unit}</span>`; 
                };
                const perfIndex2 = analysis?.level2?.performanceIndex?.toFixed(0) ?? 'N/A';
                const perfIndex3 = analysis?.level3?.performanceIndex?.toFixed(0) ?? 'N/A';
                const perfDelta = analysis?.pressureEffect?.performanceIndex ?? 0;
                const perfChangeText = this.getPerformanceChangeText(perfDelta, perfIndex2);

                return `
                    <h3 class="text-2xl font-bold mb-4">Relatório de Desempenho - ${session.testName}</h3>
                    <p class="text-gray-600 mb-6">Realizado em: ${new Date(session.completedAt).toLocaleString('pt-BR')}</p>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                        <div class="p-4 bg-orange-50 rounded-lg">
                            <p class="text-center font-semibold">Índice de Desempenho (Nível Padrão): <span class="text-2xl font-bold ${this.getPerformanceColor(perfIndex2, 'text')}">${perfIndex2}</span></p>
                        </div>
                        <div class="p-4 bg-orange-100 rounded-lg">
                            <p class="text-center font-semibold">Índice Sob Pressão (Nível 3): <span class="text-2xl font-bold ${this.getPerformanceColor(perfIndex3, 'text')}">${perfIndex3}</span></p>
                            <p class="text-center mt-2">${perfChangeText}</p>
                        </div>
                    </div>
                    ${this.renderIndexLegend()}
                    <table class="w-full text-left border-collapse">
                        <thead><tr class="bg-gray-100"><th class="p-3 border-b">Métrica</th><th class="p-3 border-b text-center">Nível 1 (2 alvos)</th><th class="p-3 border-b text-center">Nível 2 (3 alvos)</th><th class="p-3 border-b text-center">Nível 3 (Pressão)</th><th class="p-3 border-b text-center">Efeito Sob Pressão (N3-N2)</th></tr></thead>
                        <tbody>
                            <tr><td class="p-3 font-medium border-b">Tempo Médio (ms)<p class="text-xs text-gray-500 italic font-normal">Velocidade de resposta.</p></td><td class="p-3 text-center border-b">${analysis.level1.meanRT.toFixed(0)}</td><td class="p-3 text-center border-b">${analysis.level2.meanRT.toFixed(0)}</td><td class="p-3 text-center border-b">${analysis.level3.meanRT.toFixed(0)}</td><td class="p-3 text-center border-b font-bold">${analysis.pressureEffect ? formatDelta(analysis.pressureEffect.meanRT, 'ms') : '-'}</td></tr>
                            <tr><td class="p-3 font-medium border-b">Estabilidade (CV%)<p class="text-xs text-gray-500 italic font-normal">Consistência da resposta.</p></td><td class="p-3 text-center border-b">${analysis.level1.stability.toFixed(2)}</td><td class="p-3 text-center border-b">${analysis.level2.stability.toFixed(2)}</td><td class="p-3 text-center border-b">${analysis.level3.stability.toFixed(2)}</td><td class="p-3 text-center border-b font-bold">${analysis.pressureEffect ? formatDelta(analysis.pressureEffect.stability, '%') : '-'}</td></tr>
                            <tr><td class="p-3 font-medium border-b">Acurácia (%)<p class="text-xs text-gray-500 italic font-normal">Percentual de acertos.</p></td><td class="p-3 text-center border-b">${analysis.level1.accuracy.toFixed(2)}</td><td class="p-3 text-center border-b">${analysis.level2.accuracy.toFixed(2)}</td><td class="p-3 text-center border-b">${analysis.level3.accuracy.toFixed(2)}</td><td class="p-3 text-center border-b font-bold">${analysis.pressureEffect ? formatDelta(analysis.pressureEffect.accuracy, '%', false) : '-'}</td></tr>
                            <tr><td class="p-3 font-medium">Erros<p class="text-xs text-gray-500 italic font-normal">Número de tentativas incorretas.</p></td><td class="p-3 text-center">${analysis.level1.errors}</td><td class="p-3 text-center">${analysis.level2.errors}</td><td class="p-3 text-center">${analysis.level3.errors}</td><td class="p-3 text-center font-bold">${analysis.pressureEffect ? formatDelta(analysis.pressureEffect.errors, '') : '-'}</td></tr>
                        </tbody>
                    </table>`;
            },
            closeReportModal() { this.reportModal.classList.add('hidden'); this.reportModal.classList.remove('flex'); },
            showTestInstructions(name, instructions) { this.testContent.innerHTML = `<h3 class="text-2xl font-bold mb-4">${name}</h3><div class="text-left max-w-md mx-auto space-y-4 mb-8">${instructions}</div><button id="start-test-btn" class="px-6 py-3 bg-green-600 text-white rounded-lg shadow hover:bg-green-700 transition text-lg">Começar</button>`; },
            prepareTestArea(showTimer = false) { 
                this.testContent.innerHTML = `
                    <div id="test-stimulus-area">
                        ${showTimer ? '<div id="countdown-timer"></div>' : ''}
                        ${showTimer ? '<div id="progress-bar-container"><div id="progress-bar"></div></div>' : ''}
                    </div>
                    <div id="test-progress" class="mt-4 text-gray-600"></div>
                `; 
                return document.getElementById('test-stimulus-area'); 
            },
            showStimulus(area, type) { area.innerHTML += `<div class="stimulus-circle ${type}"></div>`; },
            clearStimulus(area) { const c = area.querySelector('.stimulus-circle'); if (c) c.remove(); },
            updateProgress(level, current, total) { document.getElementById('test-progress').textContent = `Nível ${level} | Tentativa ${current} / ${total}`; },
            updateTimer(seconds, totalSeconds) { 
                const el = document.getElementById('countdown-timer'); 
                if(el) el.textContent = seconds; 
                
                const progressBar = document.getElementById('progress-bar');
                if (progressBar) {
                    const percentage = (seconds / totalSeconds) * 100;
                    progressBar.style.width = `${percentage}%`;
                }
            },
            showIntermediateScreen(message) { this.testContent.innerHTML = `<div class="flex flex-col items-center justify-center h-full"><p class="text-2xl">${message}</p><button id="next-action-btn" class="mt-6 px-6 py-3 bg-blue-600 text-white rounded-lg shadow hover:bg-blue-700 transition">Continuar</button></div>`; },
        };
        
        // --- LÓGICA DE DADOS (LocalStorage) ---
        const AppData = {
            ATHLETES_KEY: 'cognitive_app_athletes', SESSIONS_KEY_PREFIX: 'cognitive_app_sessions_',
            getAthletes() { try { const a = localStorage.getItem(this.ATHLETES_KEY); return a ? JSON.parse(a) : []; } catch (e) { console.error(e); return []; } },
            saveAthletes(a) { localStorage.setItem(this.ATHLETES_KEY, JSON.stringify(a)); },
            addOrUpdateAthlete(d) { let a = this.getAthletes(); if (d.id) { const i = a.findIndex(x => x.id === d.id); if (i > -1) a[i] = { ...a[i], ...d }; } else { d.id = `athlete_${new Date().getTime()}`; d.createdAt = new Date().toISOString(); a.push(d); } this.saveAthletes(a); },
            getAthlete(id) { return this.getAthletes().find(a => a.id === id) || null; },
            deleteAthlete(id) {
                let a = this.getAthletes();
                a = a.filter(x => x.id !== id);
                this.saveAthletes(a);
                localStorage.removeItem(`${this.SESSIONS_KEY_PREFIX}${id}`);
            },
            getAthleteSessions(id) { try { const s = localStorage.getItem(`${this.SESSIONS_KEY_PREFIX}${id}`); return s ? JSON.parse(s) : []; } catch (e) { console.error(e); return []; } },
            saveSessionResults(id, name, results) { let s = this.getAthleteSessions(id); const n = { testName: name, analysis: results.analysis, levelData: results.levelData, completedAt: new Date().toISOString() }; s.push(n); localStorage.setItem(`${this.SESSIONS_KEY_PREFIX}${id}`, JSON.stringify(s)); },
            deleteSession(athleteId, sessionIndex) {
                let sessions = this.getAthleteSessions(athleteId);
                sessions.sort((a,b) => new Date(b.completedAt) - new Date(a.completedAt));
                sessions.splice(sessionIndex, 1);
                localStorage.setItem(`${this.SESSIONS_KEY_PREFIX}${athleteId}`, JSON.stringify(sessions));
            },
            updateSessionByTimestamp(athleteId, timestamp, updatedSession) {
                let sessions = this.getAthleteSessions(athleteId);
                const indexToUpdate = sessions.findIndex(s => s.completedAt === timestamp);
                if (indexToUpdate > -1) {
                    sessions[indexToUpdate] = updatedSession;
                    localStorage.setItem(`${this.SESSIONS_KEY_PREFIX}${athleteId}`, JSON.stringify(sessions));
                    console.log(`Sessão de ${timestamp} atualizada no localStorage.`);
                }
            }
        };
        
        // --- MÓDULO EXECUTOR DE TESTES ---
        const TestRunner = {
            currentAthleteId: null, isCancelled: false,
            async startTest(athleteId, testFunction) {
                this.isCancelled = false;
                AudioManager.init();
                this.currentAthleteId = athleteId;
                UI.enterFullscreen();
                UI.showView('testRunner');
                await testFunction.call(this);
                if (!this.isCancelled) {
                    this.endTest();
                }
            },
            endTest() { 
                UI.exitFullscreen();
                const athlete = AppData.getAthlete(this.currentAthleteId); 
                const sessions = AppData.getAthleteSessions(this.currentAthleteId); 
                UI.renderAthleteProfile(athlete, sessions); 
                UI.showView('profile'); 
            },
            cancelTest() {
                this.isCancelled = true;
                AudioManager.stopBeep();
                this.endTest();
            },
            async runGoNoGoTest() { const levels = [ { name: 'Nível 1: Aprendizagem', trials: 5, goPercentage: 0.60, pressure: false }, { name: 'Nível 2: Padrão', trials: 12, goPercentage: 0.75, pressure: false }, { name: 'Nível 3: Sob Pressão', trials: 12, goPercentage: 0.75, pressure: true, duration: 45 } ]; const commonConfig = { stimulusDuration: 1000, minInterval: 1000, maxInterval: 2000 }; const instructions = `<p>Clique no <strong>círculo VERDE</strong> o mais rápido que puder, <strong>antes que ele desapareça</strong>.</p><p><strong>NÃO</strong> clique no círculo com a <strong>borda VERMELHA</strong>.</p><p>Mantenha o foco e prepare-se.</p>`; UI.showTestInstructions("Teste de Reação e Inibição", instructions); await new Promise(r => { if(this.isCancelled) return; document.getElementById('start-test-btn').onclick = r; }); const results = { levelData: [] }; for (let i = 0; i < levels.length; i++) { if (this.isCancelled) return; const level = levels[i]; UI.showIntermediateScreen(`Prepare-se para o ${level.name}`); await new Promise(r => { if(this.isCancelled) return; document.getElementById('next-action-btn').onclick = r; }); const stimulusArea = UI.prepareTestArea(level.pressure); const trials = this.generateGoNoGoTrials(level.trials, level.goPercentage); const levelRawData = []; let timerInterval; if (level.pressure) { AudioManager.startAcceleratingBeep(level.duration); let timeLeft = level.duration; UI.updateTimer(timeLeft, level.duration); timerInterval = setInterval(() => { if(this.isCancelled) { clearInterval(timerInterval); return; } timeLeft--; UI.updateTimer(timeLeft, level.duration); if (timeLeft <= 0) { clearInterval(timerInterval); AudioManager.stopBeep(); } }, 1000); } for (let j = 0; j < trials.length; j++) { if (this.isCancelled) { if (timerInterval) clearInterval(timerInterval); AudioManager.stopBeep(); return; } UI.updateProgress(i + 1, j + 1, trials.length); await new Promise(r => setTimeout(r, Math.random() * (commonConfig.maxInterval - commonConfig.minInterval) + commonConfig.minInterval)); levelRawData.push(await this.executeSingleTrial(stimulusArea, trials[j], commonConfig.stimulusDuration)); } if (level.pressure) AudioManager.stopBeep(); if (timerInterval) clearInterval(timerInterval); results.levelData.push({ level: i + 1, rawData: levelRawData, trials: level.trials }); } if (this.isCancelled) return; results.analysis = Analysis.analyzeGoNoGoResults(results.levelData); AppData.saveSessionResults(this.currentAthleteId, 'Go/No-Go', results); },
            generateGoNoGoTrials(total, goPercentage) { const t = []; const g = Math.floor(total * goPercentage); for (let i = 0; i < g; i++) t.push({ type: 'go' }); for (let i = 0; i < total - g; i++) t.push({ type: 'no-go' }); for (let i = t.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [t[i], t[j]] = [t[j], t[i]]; } return t; },
            executeSingleTrial(area, trial, duration) { return new Promise(resolve => { let start, timer; let clicked = false; const handler = (e) => { if (e.target.id !== 'test-stimulus-area') { if (clicked) return; clicked = true; const rt = performance.now() - start; clearTimeout(timer); UI.clearStimulus(area); area.removeEventListener('click', handler, true); if (trial.type === 'no-go') AudioManager.playErrorBeep(); resolve({ type: trial.type, result: 'click', reactionTime: rt }); } }; UI.showStimulus(area, trial.type); start = performance.now(); area.addEventListener('click', handler, true); timer = setTimeout(() => { if (clicked) return; UI.clearStimulus(area); area.removeEventListener('click', handler, true); if (trial.type === 'go') AudioManager.playErrorBeep(); resolve({ type: trial.type, result: 'timeout', reactionTime: null }); }, duration); }); },
            async runStroopTest() { const colors = [ { name: 'Vermelho', hex: '#ef4444', text: 'white' }, { name: 'Verde', hex: '#22c55e', text: 'white' }, { name: 'Azul', hex: '#3b82f6', text: 'white' }, { name: 'Amarelo', hex: '#eab308', text: 'black' } ]; const levels = [ { name: 'Nível 1: Congruente', trials: 5, pressure: false, type: 'congruent' }, { name: 'Nível 2: Incongruente', trials: 12, pressure: false, type: 'incongruent' }, { name: 'Nível 3: Sob Pressão', trials: 12, pressure: true, duration: 60, type: 'incongruent' } ]; const instructions = `<p>Sua tarefa é <strong>clicar no botão com o nome da COR que você vê</strong>, ignorando o que a palavra diz.</p><p>Seja rápido e preciso.</p>`; UI.showTestInstructions("Teste de Atenção Seletiva", instructions); await new Promise(r => { if(this.isCancelled) return; document.getElementById('start-test-btn').onclick = r; }); const results = { levelData: [] }; for (let i = 0; i < levels.length; i++) { if (this.isCancelled) return; const level = levels[i]; UI.showIntermediateScreen(`Prepare-se para o ${level.name}`); await new Promise(r => { if(this.isCancelled) return; document.getElementById('next-action-btn').onclick = r; }); const stimulusArea = UI.prepareTestArea(level.pressure); const trials = this.generateStroopTrials(level.trials, level.type, colors); const levelRawData = []; let timerInterval; if (level.pressure) { AudioManager.startAcceleratingBeep(level.duration); let timeLeft = level.duration; UI.updateTimer(timeLeft, level.duration); timerInterval = setInterval(() => { if(this.isCancelled) { clearInterval(timerInterval); return; } timeLeft--; UI.updateTimer(timeLeft, level.duration); if (timeLeft <= 0) { clearInterval(timerInterval); AudioManager.stopBeep(); } }, 1000); } for (let j = 0; j < trials.length; j++) { if (this.isCancelled) { if (timerInterval) clearInterval(timerInterval); AudioManager.stopBeep(); return; } UI.updateProgress(i + 1, j + 1, trials.length); await new Promise(r => setTimeout(r, 1000)); levelRawData.push(await this.executeStroopTrial(stimulusArea, trials[j])); } if (level.pressure) AudioManager.stopBeep(); if (timerInterval) clearInterval(timerInterval); results.levelData.push({ level: i + 1, rawData: levelRawData }); } if (this.isCancelled) return; results.analysis = Analysis.analyzeStroopResults(results.levelData); AppData.saveSessionResults(this.currentAthleteId, 'Atenção Seletiva', results); },
            generateStroopTrials(numTrials, type, colors) {
                const trials = [];
                for (let i = 0; i < numTrials; i++) {
                    const correctColorIndex = Math.floor(Math.random() * colors.length);
                    const correctColor = colors[correctColorIndex];
                    let wordText;
                    if (type === 'congruent') {
                        wordText = correctColor.name;
                    } else {
                        let wordColorIndex;
                        do {
                            wordColorIndex = Math.floor(Math.random() * colors.length);
                        } while (wordColorIndex === correctColorIndex);
                        wordText = colors[wordColorIndex].name;
                    }

                    let distractorColor;
                    do {
                        const distractorIndex = Math.floor(Math.random() * colors.length);
                        distractorColor = colors[distractorIndex];
                    } while (distractorColor.name === correctColor.name);

                    const choices = [correctColor, distractorColor];

                    // Shuffle the two choices
                    if (Math.random() > 0.5) {
                        [choices[0], choices[1]] = [choices[1], choices[0]];
                    }

                    trials.push({ type, wordText, colorHex: correctColor.hex, textColor: correctColor.text, choices, correctChoice: correctColor.name });
                }
                return trials;
            },
            executeStroopTrial(area, trial) { return new Promise(async (resolve) => { const stimulusHtml = `<div id="stroop-stimulus" style="color: ${trial.colorHex};">${trial.wordText}</div>`; const choicesHtml = trial.choices.map(choice => `<button class="stroop-choice-btn">${choice.name}</button>`).join(''); area.innerHTML = `<div id="stroop-stimulus-container">${stimulusHtml}</div><div id="stroop-choices">${choicesHtml}</div>`; const startTime = performance.now(); const choiceButtons = area.querySelectorAll('.stroop-choice-btn'); const clickHandler = async (e) => { choiceButtons.forEach(btn => btn.disabled = true); e.target.classList.add('clicked'); const reactionTime = performance.now() - startTime; const choiceText = e.target.textContent; const result = choiceText === trial.correctChoice ? 'correct' : 'incorrect'; if (result === 'incorrect') { AudioManager.playErrorBeep(); } await new Promise(r => setTimeout(r, 250)); resolve({ ...trial, result, reactionTime }); }; choiceButtons.forEach(btn => btn.addEventListener('click', clickHandler)); }); },
            async runWorkingMemoryTest() { const levels = [ { name: 'Nível 1: 3 itens', trials: 5, items: 3, pressure: false }, { name: 'Nível 2: 4 itens', trials: 12, items: 4, pressure: false }, { name: 'Nível 3: 4 itens com pressão', trials: 12, items: 4, pressure: true, duration: 90 } ]; const commonConfig = { stimulusDuration: 1700, distractorDuration: 200, feedbackDuration: 200, interTrialDelay: 1000 }; const instructions = `<p>Observe a posição dos quadrados azuis na grade.</p><p>Após eles desaparecerem, clique para selecionar os quadrados que você memorizou.</p>`; UI.showTestInstructions("Teste de Memória de Trabalho", instructions); await new Promise(r => { if(this.isCancelled) return; document.getElementById('start-test-btn').onclick = r; }); const results = { levelData: [] }; for (let i = 0; i < levels.length; i++) { if (this.isCancelled) return; const level = levels[i]; UI.showIntermediateScreen(`Prepare-se para o ${level.name}`); await new Promise(r => { if(this.isCancelled) return; document.getElementById('next-action-btn').onclick = r; }); const stimulusArea = UI.prepareTestArea(level.pressure); const levelRawData = []; let timerInterval; if (level.pressure) { AudioManager.startAcceleratingBeep(level.duration); let timeLeft = level.duration; UI.updateTimer(timeLeft, level.duration); timerInterval = setInterval(() => { if(this.isCancelled) { clearInterval(timerInterval); return; } timeLeft--; UI.updateTimer(timeLeft, level.duration); if (timeLeft <= 0) { clearInterval(timerInterval); AudioManager.stopBeep(); } }, 1000); } for (let j = 0; j < level.trials; j++) { if (this.isCancelled) { if (timerInterval) clearInterval(timerInterval); AudioManager.stopBeep(); return; } UI.updateProgress(i + 1, j + 1, level.trials); levelRawData.push(await this.executeWorkingMemoryTrial(stimulusArea, level.items, commonConfig)); stimulusArea.innerHTML = ''; await new Promise(r => setTimeout(r, commonConfig.interTrialDelay)); } if (level.pressure) AudioManager.stopBeep(); if (timerInterval) clearInterval(timerInterval); results.levelData.push({ level: i + 1, rawData: levelRawData }); } if (this.isCancelled) return; results.analysis = Analysis.analyzeWorkingMemoryResults(results.levelData); AppData.saveSessionResults(this.currentAthleteId, 'Memória de Trabalho', results); },
            generateWorkingMemoryTrial(gridSize, numItems) { const positions = new Set(); while (positions.size < numItems) { positions.add(Math.floor(Math.random() * gridSize)); } return Array.from(positions); },
            executeWorkingMemoryTrial(area, numItems, config) { return new Promise(async resolve => { const correctPositions = new Set(this.generateWorkingMemoryTrial(25, numItems)); area.innerHTML = `<div id="wm-grid"></div>`; const grid = area.querySelector('#wm-grid'); for (let i = 0; i < 25; i++) { grid.appendChild(document.createElement('div')).className = 'wm-cell'; } const cells = Array.from(grid.children); correctPositions.forEach(pos => cells[pos].classList.add('stimulus')); await new Promise(r => setTimeout(r, config.stimulusDuration)); grid.style.visibility = 'hidden'; await new Promise(r => setTimeout(r, config.distractorDuration)); cells.forEach(cell => cell.classList.remove('stimulus')); grid.style.visibility = 'visible'; const startTime = performance.now(); const selectedPositions = new Set(); cells.forEach((cell, i) => { cell.classList.add('selectable'); cell.dataset.index = i; }); const clickHandler = async (e) => { const cell = e.target.closest('.wm-cell.selectable'); if (!cell) return; const clickedIndex = parseInt(cell.dataset.index); if (!selectedPositions.has(clickedIndex)) { selectedPositions.add(clickedIndex); cell.classList.add('selected'); } if (selectedPositions.size === correctPositions.size) { grid.removeEventListener('click', clickHandler); const isCorrect = [...selectedPositions].every(pos => correctPositions.has(pos)); const reactionTime = performance.now() - startTime; if (!isCorrect) AudioManager.playErrorBeep(); await new Promise(r => setTimeout(r, config.feedbackDuration)); resolve({ result: isCorrect ? 'correct' : 'incorrect', reactionTime }); } }; grid.addEventListener('click', clickHandler); }); },
            async runVisualMappingTest() { const levels = [ { name: 'Nível 1: 2 alvos', trials: 3, targets: 2, speed: 4, pressure: false }, { name: 'Nível 2: 3 alvos', trials: 5, targets: 3, speed: 5, pressure: false }, { name: 'Nível 3: 3 alvos com pressão', trials: 5, targets: 3, speed: 5, pressure: true, duration: 75 } ]; const instructions = `<p>Observe as bolinhas se moverem.</p><p>Algumas delas piscarão em amarelo. Memorize quais são.</p><p>Quando elas pararem, clique nas bolinhas que piscaram.</p>`; UI.showTestInstructions("Teste de Mapeamento Visual", instructions); await new Promise(r => { if(this.isCancelled) return; document.getElementById('start-test-btn').onclick = r; }); const results = { levelData: [] }; for (let i = 0; i < levels.length; i++) { if (this.isCancelled) return; const level = levels[i]; UI.showIntermediateScreen(`Prepare-se para o ${level.name}`); await new Promise(r => { if(this.isCancelled) return; document.getElementById('next-action-btn').onclick = r; }); const stimulusArea = UI.prepareTestArea(level.pressure); const levelRawData = []; let timerInterval; if (level.pressure) { AudioManager.startAcceleratingBeep(level.duration); let timeLeft = level.duration; UI.updateTimer(timeLeft, level.duration); timerInterval = setInterval(() => { if(this.isCancelled) { clearInterval(timerInterval); return; } timeLeft--; UI.updateTimer(timeLeft, level.duration); if (timeLeft <= 0) { clearInterval(timerInterval); AudioManager.stopBeep(); } }, 1000); } for (let j = 0; j < level.trials; j++) { if (this.isCancelled) { if (timerInterval) clearInterval(timerInterval); AudioManager.stopBeep(); return; } UI.updateProgress(i + 1, j + 1, level.trials); levelRawData.push(await this.executeVisualMappingTrial(stimulusArea, level.targets, level.speed, 12, 18)); } if (level.pressure) AudioManager.stopBeep(); if (timerInterval) clearInterval(timerInterval); results.levelData.push({ level: i + 1, rawData: levelRawData, trials: level.trials }); } if (this.isCancelled) return; results.analysis = Analysis.analyzeVisualMappingResults(results.levelData); AppData.saveSessionResults(this.currentAthleteId, 'Mapeamento Visual', results); },
            executeVisualMappingTrial(area, numTargets, speed, numBalls = 12, radius = 15) { return new Promise(resolve => { area.innerHTML = '<canvas id="vm-canvas"></canvas>'; const canvas = area.querySelector('#vm-canvas'); const ctx = canvas.getContext('2d'); const dpr = window.devicePixelRatio || 1; const rect = area.getBoundingClientRect(); canvas.width = rect.width * dpr; canvas.height = rect.height * dpr; ctx.scale(dpr, dpr); canvas.style.width = `${rect.width}px`; canvas.style.height = `${rect.height}px`; const dots = []; for (let i = 0; i < numBalls; i++) { dots.push({ x: Math.random() * (canvas.width / dpr - radius * 2) + radius, y: Math.random() * (canvas.height / dpr - radius * 2) + radius, vx: (Math.random() - 0.5) * speed, vy: (Math.random() - 0.5) * speed, radius: radius, isTarget: false }); } const targetIndexes = new Set(); while(targetIndexes.size < numTargets) { targetIndexes.add(Math.floor(Math.random() * dots.length)); } targetIndexes.forEach(i => dots[i].isTarget = true); let animationFrameId; let phase = 'initialMove'; const phaseDurations = { initialMove: 3000, static: 1700, flash: 700, finalMove: 5000 }; let phaseStartTime = performance.now(); const drawDot = (dot, color = '#3b82f6') => { ctx.beginPath(); ctx.arc(dot.x, dot.y, dot.radius, 0, Math.PI * 2); ctx.fillStyle = color; ctx.fill(); ctx.closePath(); }; const update = () => { dots.forEach(dot => { dot.x += dot.vx; dot.y += dot.vy; if (dot.x - dot.radius < 0 || dot.x + dot.radius > canvas.width / dpr) dot.vx *= -1; if (dot.y - dot.radius < 0 || dot.y + dot.radius > canvas.height / dpr) dot.vy *= -1; }); }; const animate = (time) => { if (this.isCancelled) { cancelAnimationFrame(animationFrameId); return; } const elapsed = time - phaseStartTime; ctx.clearRect(0, 0, canvas.width, canvas.height); switch(phase) { case 'initialMove': update(); dots.forEach(dot => drawDot(dot)); if (elapsed > phaseDurations.initialMove) { phase = 'static'; phaseStartTime = time; } break; case 'static': dots.forEach(dot => drawDot(dot)); if (elapsed > phaseDurations.static) { phase = 'flash'; phaseStartTime = time; } break; case 'flash': dots.forEach(dot => drawDot(dot, dot.isTarget && Math.floor(elapsed / 100) % 2 === 0 ? '#eab308' : '#3b82f6')); if (elapsed > phaseDurations.flash) { phase = 'finalMove'; phaseStartTime = time; } break; case 'finalMove': update(); dots.forEach(dot => drawDot(dot)); if (elapsed > phaseDurations.finalMove) { cancelAnimationFrame(animationFrameId); waitForResponse(); return; } break; } animationFrameId = requestAnimationFrame(animate); }; const waitForResponse = () => { ctx.clearRect(0, 0, canvas.width, canvas.height); dots.forEach(dot => drawDot(dot)); const responseStartTime = performance.now(); const selectedDots = new Set(); const clickHandler = (e) => { const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top; dots.forEach((dot, index) => { const distance = Math.sqrt(Math.pow(x - dot.x, 2) + Math.pow(y - dot.y, 2)); if (distance < dot.radius) { if (selectedDots.has(index)) { selectedDots.delete(index); drawDot(dot, '#3b82f6'); } else { if (selectedDots.size < numTargets) { selectedDots.add(index); drawDot(dot, dot.isTarget ? '#22c55e' : '#ef4444'); } } if(selectedDots.size === numTargets) { canvas.removeEventListener('click', clickHandler); const reactionTime = performance.now() - responseStartTime; const correctSelections = [...selectedDots].filter(i => dots[i].isTarget).length; const result = correctSelections === numTargets ? 'correct' : 'incorrect'; if (result === 'incorrect') AudioManager.playErrorBeep(); setTimeout(() => resolve({ result, reactionTime }), 1500); } } }); }; canvas.addEventListener('click', clickHandler); }; animationFrameId = requestAnimationFrame(animate); }); },
        };

        // --- LÓGICA PRINCIPAL E EVENTOS ---
        function getAge(dateString) { if (!dateString) return ''; const today = new Date(); const birthDate = new Date(dateString); let age = today.getFullYear() - birthDate.getFullYear(); const m = today.getMonth() - birthDate.getMonth(); if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) { age--; } return age; }
        function refreshAthleteList() { const athletes = AppData.getAthletes().sort((a, b) => a.name.localeCompare(b.name)); UI.renderAthleteList(athletes); }
        
        // CORREÇÃO: Movida a inicialização e os event listeners para uma função separada.
        function initializeApp() {
            UI.init();
            
            refreshAthleteList();
            
            document.getElementById('nav-dashboard').addEventListener('click', () => { UI.showView('dashboard'); refreshAthleteList(); });
            document.getElementById('back-to-dashboard-btn').addEventListener('click', () => { 
                const athleteId = UI.athleteProfileContent.dataset.currentAthleteId;
                if(athleteId) {
                    const athlete = AppData.getAthlete(athleteId);
                    const sessions = AppData.getAthleteSessions(athleteId);
                    UI.renderAthleteProfile(athlete, sessions);
                }
                UI.showView('dashboard'); 
                refreshAthleteList(); 
            });
            document.getElementById('add-athlete-btn').addEventListener('click', () => UI.openModal());
            document.getElementById('cancel-btn').addEventListener('click', () => UI.closeModal());
            document.getElementById('close-report-btn').addEventListener('click', () => {
                 const athleteId = UI.athleteProfileContent.dataset.currentAthleteId;
                if(athleteId) {
                    const athlete = AppData.getAthlete(athleteId);
                    const sessions = AppData.getAthleteSessions(athleteId);
                    UI.renderAthleteProfile(athlete, sessions);
                }
                UI.closeReportModal()
            });
            document.getElementById('close-global-suggestions-btn').addEventListener('click', () => UI.closeGlobalSuggestionsModal());
            document.getElementById('cancel-test-btn').addEventListener('click', () => TestRunner.cancelTest());
            
            UI.athleteForm.addEventListener('submit', (e) => { e.preventDefault(); const d = { id: document.getElementById('athlete-id').value, name: document.getElementById('name').value, dob: document.getElementById('dob').value, sport: document.getElementById('sport').value, gender: document.getElementById('gender').value, }; AppData.addOrUpdateAthlete(d); UI.closeModal(); refreshAthleteList(); });
            
            UI.athleteList.addEventListener('click', (e) => {
                const t = e.target.closest('button');
                if (!t) return;
                const id = t.dataset.id;
                if (t.classList.contains('view-btn')) {
                    const a = AppData.getAthlete(id);
                    if (a) {
                        const s = AppData.getAthleteSessions(id);
                        UI.renderAthleteProfile(a, s);
                        UI.showView('profile');
                    }
                } else if (t.classList.contains('edit-btn')) {
                    const a = AppData.getAthlete(id);
                    if (a) { UI.openModal(a); }
                } else if (t.classList.contains('delete-btn')) {
                    AppData.deleteAthlete(id);
                    refreshAthleteList();
                }
            });

            UI.athleteProfileContent.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (!button) return;

                const athleteId = UI.athleteProfileContent.dataset.currentAthleteId;
                if (!athleteId) return;

                const testId = button.dataset.testid;

                if (testId === 'start-gong-test') {
                    TestRunner.startTest(athleteId, TestRunner.runGoNoGoTest);
                } else if (testId === 'start-stroop-test') {
                    TestRunner.startTest(athleteId, TestRunner.runStroopTest);
                } else if (testId === 'start-wm-test') {
                    TestRunner.startTest(athleteId, TestRunner.runWorkingMemoryTest);
                } else if (testId === 'start-vm-test') {
                    TestRunner.startTest(athleteId, TestRunner.runVisualMappingTest);
                } else if (button.classList.contains('view-report-btn')) {
                    const index = button.dataset.sessionIndex;
                    const sessions = AppData.getAthleteSessions(athleteId).sort((a,b) => new Date(b.completedAt) - new Date(a.completedAt));
                    if (sessions[index]) UI.openReportModal(sessions[index], athleteId);
                } else if (button.classList.contains('delete-report-btn')) {
                    const index = button.dataset.sessionIndex;
                    AppData.deleteSession(athleteId, index);
                    const a = AppData.getAthlete(athleteId);
                    const s = AppData.getAthleteSessions(athleteId);
                    UI.renderAthleteProfile(a, s);
                } else if (button.id === 'generate-global-plan-btn') {
                    const sessions = AppData.getAthleteSessions(athleteId);
                    const plan = SuggestionEngine.generateGlobalPlan(sessions);
                    UI.openGlobalSuggestionsModal(plan);
                }
            });
        }

        // Garante que o script só rode depois que a página estiver totalmente carregada
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }

    </script>

<script>
function enviarParaFirebase() {
    const atleta = AppData.currentAthlete;
    const sessao = AppData.currentSession;

    if (!atleta || !sessao) {
        alert("⚠️ Os dados ainda não estão disponíveis. Por favor, feche e abra o relatório novamente.");
        return;
    }

    const nome = atleta.name || "";
    const modalidade = atleta.sport || "";

    let idade = "";
    try {
        const nascimento = new Date(atleta.dob);
        const hoje = new Date();
        idade = hoje.getFullYear() - nascimento.getFullYear();
        const m = hoje.getMonth() - nascimento.getMonth();
        if (m < 0 || (m === 0 && hoje.getDate() < nascimento.getDate())) {
            idade--;
        }
    } catch (e) {
        idade = "";
    }

    let indiceN2 = 0;
    let indiceN3 = 0;
    if (sessao.analysis?.level2?.performanceIndex !== undefined) {
        indiceN2 = Math.round(sessao.analysis.level2.performanceIndex);
    }
    if (sessao.analysis?.level3?.performanceIndex !== undefined) {
        indiceN3 = Math.round(sessao.analysis.level3.performanceIndex);
    }

    const data = new Date().toISOString();

    if (!nome || !idade || !modalidade || indiceN3 === 0) {
        alert("❌ Dados incompletos. O relatório ainda não está carregado corretamente.");
        return;
    }

    firebase.firestore().collection("Cogteste").add({
        Nome: nome,
        Idade: idade,
        Modalidade: modalidade,
        Data: data,
        "Índice N2": indiceN2,
        "Índice N3": indiceN3
    }).then(() => {
        alert("✅ Resultado enviado com sucesso para o Firebase!");
    }).catch((error) => {
        alert("❌ Erro ao enviar: " + error.message);
    });
}
</script>

<script>
  function enviarParaFirebase() {
    const reportEl = document.getElementById("report-content");
    if (!reportEl) {
      alert("Erro: relatório não encontrado.");
      return;
    }

    const nome = document.querySelector("#athlete-profile-content h2")?.textContent?.trim();
    const idadeTexto = document.querySelector("#athlete-profile-content p")?.textContent;
    const modalidadeMatch = idadeTexto?.match(/\|\s*(.*?)\s*\|/);
    const idadeMatch = idadeTexto?.match(/(\d+)\s*anos/);

    const modalidade = modalidadeMatch ? modalidadeMatch[1] : "";
    const idade = idadeMatch ? parseInt(idadeMatch[1]) : null;

    const tituloRelatorio = reportEl.querySelector("h3")?.textContent || "";
    const testeMatch = tituloRelatorio.match(/- (.*)/);
    const teste = testeMatch ? testeMatch[1].trim() : "Desconhecido";

    const indiceN2 = reportEl.innerHTML.match(/Nível Padrão[^0-9]*?(\d+)/);
    const indiceN3 = reportEl.innerHTML.match(/Índice Sob Pressão[^0-9]*?(\d+)/);

    const n2 = indiceN2 ? parseInt(indiceN2[1]) : 0;
    const n3 = indiceN3 ? parseInt(indiceN3[1]) : 0;

    if (!nome || !idade || !modalidade) {
      alert("Erro ao extrair os dados do atleta.");
      return;
    }

    enviarTesteParaFirebase(nome, idade, modalidade, teste, n2, n3);
  }
</script>

</body>

</html>