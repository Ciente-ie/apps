<script>
let tipoTeste = 1;
let fator = parseFloat(localStorage.getItem('fatorCorrecao')) || 1.53;
document.getElementById("fatorInput").value = fator;
document.getElementById("fatorInput").oninput = function() {
  fator = parseFloat(this.value);
  localStorage.setItem('fatorCorrecao', fator);
};

const statusDiv = document.getElementById('status');
const resultadoDiv = document.getElementById('resultado');
const cancelarBtn = document.getElementById('cancelarBtn');
const ctx = document.getElementById('grafico').getContext('2d');
const chart = new Chart(ctx, {
  type: 'line',
  data: { labels: [], datasets: [{ label: '', data: [], borderColor: '#2563eb', borderWidth: 2, pointRadius: 2, pointBackgroundColor: '#1d4ed8', tension: 0.3 }] },
  options: {
    responsive: true,
    animation: false,
    scales: {
      y: {
        beginAtZero: true,
        min: 0,
        max: 50,
        ticks: { stepSize: 5 }
      },
      x: {
        display: true,
        ticks: { display: false }
      }
    },
    plugins: {
      legend: {
        display: true,
        labels: { font: { size: 14 }, color: '#111' }
      },
      tooltip: {
        enabled: true,
        mode: 'nearest',
        intersect: false
      }
    },
    elements: {
      line: { borderWidth: 2 },
      point: { radius: 2 }
    }
  }
});

function plotar(valor) {
  chart.data.labels.push('');
  chart.data.datasets[0].data.push(valor);
  if (chart.data.labels.length > 100) {
    chart.data.labels.shift();
    chart.data.datasets[0].data.shift();
  }
  chart.update();
}

function beep() {
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const o = ctx.createOscillator();
  const g = ctx.createGain();
  o.type = "sine";
  o.connect(g);
  g.connect(ctx.destination);
  o.start();
  g.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + 0.5);
  o.stop(ctx.currentTime + 0.5);
}

let cancelado = false;

function iniciarTeste(tipo) {
  tipoTeste = tipo;
  resultadoDiv.innerHTML = '';
  chart.data.labels = [];
  chart.data.datasets[0].data = [];
  chart.data.datasets[0].label = tipo === 1 ? 'Aceleração (m/s²)' : 'Pico de Aceleração (m/s²)';
  chart.update();
  cancelado = false;
  cancelarBtn.classList.toggle('hidden', tipo !== 10);

  if (tipo === 10) {
    iniciarSequencia10Saltos();
    return;
  }

  statusDiv.innerText = 'Aguardando salto...';
  capturarSalto((altura, tempoVoo, picoAceleracao) => {
    resultadoDiv.innerHTML = `<b>Altura estimada:</b> ${altura.toFixed(2)} cm<br><small>Tempo de voo: ${tempoVoo.toFixed(3)} s</small>`;
  });
}

function cancelarTeste() {
  cancelado = true;
  statusDiv.innerText = "Teste cancelado.";
  window.removeEventListener('devicemotion', motionHandler);
}

// Função NOVA para capturar salto E retornar o pico de aceleração
function capturarSalto(callback) {
  let saltou = false;
  let tDecolagem = 0;
  let picoAceleracao = 0;
  let emCaptura = true;

  function motionHandler(e) {
    if (!emCaptura) return;
    const acc = e.accelerationIncludingGravity;
    const now = Date.now();
    const modulo = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2);

    if (modulo > picoAceleracao) picoAceleracao = modulo;

    if (tipoTeste === 1) plotar(modulo);

    if (!saltou && modulo < 3) {
      saltou = true;
      tDecolagem = now;
      statusDiv.innerText = 'No ar!';
    }

    if (saltou && modulo > 10) {
      emCaptura = false;
      const tPouso = now;
      const tempoVoo = (tPouso - tDecolagem) / 1000;
      const altura = (9.81 * tempoVoo * tempoVoo) / 8 * 100 * fator;
      statusDiv.innerText = 'Salto registrado!';
      window.removeEventListener('devicemotion', motionHandler);
      if (callback) callback(altura, tempoVoo, picoAceleracao);
    }
  }

  if (typeof DeviceMotionEvent.requestPermission === 'function') {
    DeviceMotionEvent.requestPermission().then(permissionState => {
      if (permissionState === 'granted') {
        window.addEventListener('devicemotion', motionHandler);
      } else {
        alert('Permissão negada para acessar o acelerômetro.');
      }
    }).catch(console.error);
  } else {
    window.addEventListener('devicemotion', motionHandler);
  }
}

function iniciarSequencia10Saltos() {
  const picos = [];
  let atual = 0;

  function proximoSalto() {
    if (cancelado) return;
    if (atual >= 10) {
      cancelarBtn.classList.add('hidden');
      // Gráfico dos 10 picos de aceleração
      chart.data.labels = picos.map((_, i) => `Salto ${i+1}`);
      chart.data.datasets[0].data = [...picos];
      chart.update();

      // Calcular médias e fadiga com base na aceleração!
      const primeiros = picos.slice(0, 3);
      const ultimos = picos.slice(-3);
      const media = arr => arr.reduce((a, b) => a + b, 0) / arr.length;
      const media1 = media(primeiros);
      const media2 = media(ultimos);
      const fadigaPercentual = ((media1 - media2) / media1) * 100;

      let interpretacao = '';
      if (Math.abs(fadigaPercentual) <= 5) {
        interpretacao = 'O atleta manteve o desempenho durante o teste.';
      } else if (fadigaPercentual > 5) {
        interpretacao = `O atleta apresentou queda de ${fadigaPercentual.toFixed(1)}% no desempenho.`;
      } else {
        interpretacao = `O atleta apresentou melhora de ${Math.abs(fadigaPercentual).toFixed(1)}% no desempenho.`;
      }

      resultadoDiv.innerHTML += `<hr><b>Índice de Fadiga:</b> ${fadigaPercentual.toFixed(1)}%<br><small>Média 3 primeiros: ${media1.toFixed(2)} | Últimos: ${media2.toFixed(2)}</small><br>${interpretacao}`;
      return;
    }

    statusDiv.innerText = `Aguardando salto ${atual + 1}...`;
    capturarSalto((altura, tempoVoo, picoAceleracao) => {
      resultadoDiv.innerHTML += `<b>Salto ${atual + 1}:</b> Pico de aceleração = ${picoAceleracao.toFixed(2)} m/s²<br>`;
      picos.push(picoAceleracao);
      atual++;
      setTimeout(() => {
        beep();
        proximoSalto();
      }, 2000);
    });
  }

  proximoSalto();
}
</script>
